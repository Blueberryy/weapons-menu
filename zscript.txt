version "3.2.5"

//-----------------------------------------------------------------------------
//
// Copyright 2018 mmaulwurff (Alexander Kromm)
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/
//
//-----------------------------------------------------------------------------
//

// Some code is borrowed from gzdoom.pk3:
/*
**---------------------------------------------------------------------------
** Copyright 1999-2016 Randy Heit
** Copyright 2006-2017 Christoph Oelckers
** All rights reserved.
**
** Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions
** are met:
**
** 1. Redistributions of source code must retain the above copyright
**    notice, this list of conditions and the following disclaimer.
** 2. Redistributions in binary form must reproduce the above copyright
**    notice, this list of conditions and the following disclaimer in the
**    documentation and/or other materials provided with the distribution.
** 3. The name of the author may not be used to endorse or promote products
**    derived from this software without specific prior written permission.
**
** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**---------------------------------------------------------------------------
**
*/

class WMInstaSwitcher : CustomInventory
{
  States
  {
  Pickup:
    TNT1 A 0 SetPlayerProperty(0, 1, PROP_INSTANTWEAPONSWITCH);
  }
}

class WMWeaponStub : Pistol
{
  Default
  {
    Weapon.SelectionOrder 0;
  }

  States
  {
  Ready:
    TNT1 A 1 A_WeaponReady;
    loop;
  Deselect:
    TNT1 A 1 A_Lower;
    Loop;
  Select:
    TNT1 A 1 A_Raise;
    Loop;
  }
}

class WMZscriptHelper : Actor
{
  static void TellAmmo(Actor activator, string weaponClass, bool showSecond)
  {
    if (!activator || !activator.player)
    {
      SendResult(activator, "");
      return;
    }

    Weapon w = Weapon(activator.FindInventory(weaponClass));
    if (!w)
    {
      SendResult(activator, "");
      return;
    }

    string message = "";

    Ammo amm1 = w.Ammo1;
    if (amm1)
    {
      message = String.Format("(%d/%d)", amm1.amount, amm1.maxAmount);
    }

    Ammo amm2 = w.Ammo2;
    if (showSecond && amm2 && amm1 != amm2)
    {
      message = String.Format("%s (%d/%d)", message, amm2.amount, amm2.maxAmount);
    }

    SendResult(activator, message);
  }

  static void IsWeaponReady(Actor activator, string weaponClass)
  {
    PlayerPawn p = PlayerPawn(activator);
    bool isReady = (p.player.WeaponState & WF_WEAPONREADY)
      || (p.player.WeaponState & WF_WEAPONREADYALT);
    CVar messageCVar = CVar.GetCVar("M8fWeaponMenuWeaponReady", activator.player);
    messageCVar.SetInt(isReady);
  }

  static void IsWeaponDeselectable(Actor activator, string weaponClass)
  {
    PlayerPawn p = PlayerPawn(activator);
    bool isReady = p.player.WeaponState & WF_WEAPONSWITCHOK;
    CVar messageCVar = CVar.GetCVar("M8fWeaponMenuWeaponReady", activator.player);
    messageCVar.SetInt(isReady);
  }

  static void FireWeapon(Actor activator, string weaponClass)
  {
    if (!activator || !activator.player) { return; }

    PlayerPawn p = PlayerPawn(activator);
    p.FireWeapon(null);
  }

  static void FireWeaponAlt(Actor activator, string weaponClass)
  {
    if (!activator || !activator.player) { return; }

    PlayerPawn p = PlayerPawn(activator);
    p.FireWeaponAlt(null);
  }

  static void HolsterWeapon(Actor activator)
  {
    if (!activator || !activator.player) { return; }

    activator.player.PendingWeapon = null;
  }

  static void GetInventoryList(Actor activator)
  {
    if (!activator || !activator.player) { return; }

    string inventoryContents = "";
    for (let inv = activator.player.mo.Inv; inv; inv = inv.Inv)
    {
      // [argv] look through the player pawn's inventory for weapons
      if (inv.bINVBAR)
      {
        string className = inv.GetClassName();
        string tag       = inv.GetTag();
        int amount       = inv.Amount;
        if (amount > 0)
        {
          inventoryContents.AppendFormat("%s>%s> [%d]>", className, tag, amount);
        }
        else
        {
          inventoryContents.AppendFormat("%s>%s>>", className, tag);
        }
      }
    }

    SendResult(activator, inventoryContents);
  }

  static void GetWeaponList(Actor activator)
  {
    PlayerInfo player = activator.player;
    if (!activator || !player) { return; }

    string weaponData = "";
    int nClasses = AllActorClasses.Size();

    for (int i = 0; i < nClasses; ++i)
    {
      let type = (class<Weapon>)(AllActorClasses[i]);
      if (type != null && type != "Weapon")
      {
        let rep = GetReplacement(type);
        // Don't give replaced weapons unless the replacement was done by Dehacked.
        if (rep == type || rep is "DehackedPickup")
        {
          // List the weapon only if it is set in a weapon slot.
          int slot;
          int located;
          int priority;
          [located, slot, priority] = player.weapons.LocateWeapon(type);
          if (located)
          {
            readonly<Weapon> def = GetDefaultByType(type);
            string tag           = def.GetTag();
            string className     = type.GetClassName();
            weaponData.AppendFormat("%s>%s>%d>%d>", className, tag, slot, priority);
          }
        }
      }
    }

    SendResult(activator, weaponData);
  }

  static void SendResult(Actor a, string result)
  {
    CVar messageCVar = CVar.GetCVar("M8fWeaponMenuAmmoInformerResult", a.player);
    messageCVar.SetString(result);
  }

  static void SetZoomFactor(Actor activator, double zoom)
  {
    let player = activator.player;
    if (!activator || !player) { return; }

    zoom = 1 / clamp(zoom, 0.1, 50.0);
    player.ReadyWeapon.FOVScale = zoom;
  }
}

class WM_PuffBase : Actor
{
  Default
  {
    Mass 0;
    Radius 1;
    Height 2;
    +NOBLOCKMAP;
    +NOGRAVITY;
    +BLOODLESSIMPACT;
    +PUFFONACTORS;
    +DONTSPLASH;
    +NOTRIGGER;
    +FORCEXYBILLBOARD;
  }

  States
    {
    Spawn:
      TNT1 A 0;
      WDOB A 1 BRIGHT;
      Stop;
    }
}

class WM_Laser0 : WM_PuffBase {States { Spawn: TNT1 A 0; WDO0 A 1 BRIGHT; Stop; }}
class WM_Laser1 : WM_PuffBase {States { Spawn: TNT1 A 0; WDO1 A 1 BRIGHT; Stop; }}
class WM_Laser2 : WM_PuffBase {States { Spawn: TNT1 A 0; WDO2 A 1 BRIGHT; Stop; }}
class WM_Laser3 : WM_PuffBase {States { Spawn: TNT1 A 0; WDO3 A 1 BRIGHT; Stop; }}
class WM_Laser4 : WM_PuffBase {States { Spawn: TNT1 A 0; WDO4 A 1 BRIGHT; Stop; }}
class WM_Laser5 : WM_PuffBase {States { Spawn: TNT1 A 0; WDO5 A 1 BRIGHT; Stop; }}

class WM_InvisiblePuff : WM_PuffBase {States {Spawn: TNT1 A 0; Stop;}}

class WM_JunkPuff : BulletPuff
{
  Default
  {
    +BLOODLESSIMPACT;
    +PUFFONACTORS;
    +NOBLOCKMAP;
    +NOGRAVITY;
    -ALLOWPARTICLES;
    +RANDOMIZE;
    RenderStyle "Translucent";
    Alpha 0.5;
    VSpeed 0.2;
    Mass 5;
    XScale 0.25;
    YScale 0.25;
  }

   States
   {
   Spawn:
     TNT1 A 0;
    // Intentional fall-through
   Melee:
     TNT1 A 0 A_SpawnItemEx("WM_Junk");
     WMPF CD 4;
     Stop;
  }
}

class WM_Junk : IceChunk
{
  Default
  {
    Gravity 0.5;
    XScale 0.25;
    YScale 0.25;
  }

  States
  {
  Spawn:
    TNT1 A 0;
    ICEC A 99;
    Stop;
  }
}
