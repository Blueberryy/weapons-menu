class WMZscriptHelper : Actor
{
  static void TellAmmo(Actor activator, string weaponClass, bool showSecond)
  {
    if (!activator) { return; }
    PlayerInfo player = activator.player;
    if (!player) { return; }

    Weapon w = Weapon(activator.FindInventory(weaponClass));
    if (!w)
    {
      SendResultString(player, "");
      return;
    }

    string message = "";

    Ammo amm1 = w.Ammo1;
    if (amm1)
    {
      message = String.Format("%d/%d", amm1.amount, amm1.maxAmount);
    }

    Ammo amm2 = w.Ammo2;
    if (showSecond && amm2 && amm1 != amm2)
    {
      message = String.Format("%s - %d/%d", message, amm2.amount, amm2.maxAmount);
    }

    SendResultString(player, message);
  }

  static void HasAmmo(Actor activator, string weaponClass)
  {
    if (!activator) { return; }
    PlayerInfo player = activator.player;
    if (!player) { return; }

    Weapon w = Weapon(activator.FindInventory(weaponClass));
    if (!w)
    {
      SendResultInt(player, 0);
      return;
    }

    bool result   = true;
    Ammo amm1     = w.Ammo1;
    Ammo amm2     = w.Ammo2;
    bool hasAmmo1 = (amm1 != null);
    bool hasAmmo2 = (amm2 != null);

    if (!hasAmmo1 && !hasAmmo2) { result = true; }
    else
    {
      if (hasAmmo1) { result  = (amm1.amount >= w.AmmoUse1) && w.AmmoUse1 > 0; }
      if (hasAmmo2) { result |= (amm2.amount >= w.AmmoUse2) && w.AmmoUse2 > 0; }
    }

    SendResultInt(player, result);
  }

  static void IsWeaponReady(Actor activator, string weaponClass)
  {
    if (!activator) { return; }
    PlayerInfo player = activator.player;
    if (!player) { return; }

    bool isReady = (player.WeaponState & WF_WEAPONREADY)
      || (player.WeaponState & WF_WEAPONREADYALT);
    SendResultInt(player, isReady);
  }

  static void IsWeaponDeselectable(Actor activator, string weaponClass)
  {
    if (!activator) { return; }
    PlayerInfo player = activator.player;
    if (!player) { return; }

    bool isDeselectable = player.WeaponState & WF_WEAPONSWITCHOK;
    SendResultInt(player, isDeselectable);
  }

  static void IsWeaponBeingDeselected(Actor activator)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    bool isDeselected = player.PendingWeapon.GetClassName() != "Object";
    SendResultInt(player, isDeselected);
  }

  static void FireWeapon(Actor activator, string weaponClass)
  {
    if (!activator) { return; }

    PlayerPawn pawn = PlayerPawn(activator);
    pawn.FireWeapon(null);
  }

  static void FireWeaponAlt(Actor activator, string weaponClass)
  {
    if (!activator) { return; }

    PlayerPawn pawn = PlayerPawn(activator);
    pawn.FireWeaponAlt(null);
  }

  static void HolsterWeapon(Actor activator)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    player.PendingWeapon = null;
  }

  static void GetInventoryList(Actor activator)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    string inventoryContents = "";
    int nClasses = AllActorClasses.Size();

    for (int i = 0; i < nClasses; ++i)
    {
      let type = (class<Inventory>)(AllActorClasses[i]);
      if (type == null) { continue; }

      readonly<Inventory> inv = GetDefaultByType(type);
      if (!inv.bINVBAR || inv.bAUTOACTIVATE) { continue; }

      string className = inv.GetClassName();
      string tag       = SeparateCamelCase(inv.GetTag());
      inventoryContents.AppendFormat("%s>%s>", className, tag);
    }

    SendResultString(player, inventoryContents);
  }

  static void GetInventoryTag(Actor activator, string itemClass)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    class<Inventory> type = itemClass;
    if (!type)
    {
      Console.Printf("Unknown inventory type: %s", itemClass);
      SendResultString(player, "unknown");
      return;
    }

    readonly<Inventory> defaultItem = GetDefaultByType(type);
    if (!defaultItem)
    {
      Console.Printf("Unknown inventory type: %s", itemClass);
      SendResultString(player, "unknown");
      return;
    }

    string tag = defaultItem.GetTag();

    SendResultString(player, tag);
  }

  static void GetSelectedInventory(Actor activator)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    PlayerPawn pawn = PlayerPawn(activator);

    if (pawn && pawn.InvSel != null)
    {
      SendResultString(player, pawn.InvSel.GetClassName());
    }
    else
    {
      SendResultString(player, "wm_none");
    }
  }

  static void SetSelectedInventory(Actor activator, string itemClass)
  {
    if (!activator) { return; }

    PlayerPawn pawn = PlayerPawn(activator);
    pawn.InvSel = pawn.FindInventory(itemClass);
  }

  static void GetWeaponList(Actor activator)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    string weaponData = "";
    int nClasses = AllActorClasses.Size();

    for (int i = 0; i < nClasses; ++i)
    {
      let type = (class<Weapon>)(AllActorClasses[i]);
      if (type != null && type != "Weapon")
      {
        let rep = GetReplacement(type);
        // Don't give replaced weapons unless the replacement was done by Dehacked.
        if (rep == type || rep is "DehackedPickup")
        {
          // List the weapon only if it is set in a weapon slot.
          int slot;
          int located;
          int priority;
          [located, slot, priority] = player.weapons.LocateWeapon(type);
          if (located)
          {
            readonly<Weapon> def = GetDefaultByType(type);
            if (!def.CanPickup(activator)) { continue; }

            string tag = SeparateCamelCase(def.GetTag());
            tag.Replace("_", " ");

            string className = type.GetClassName();

            // just to be sure that "serializing" will not break
            tag.Replace(">", " ");
            className.Replace(">", " ");

            weaponData.AppendFormat("%s>%s>%d>%d>", className, tag, slot, priority);
          }
        }
      }
    }

    SendResultString(player, weaponData);
  }

  static void SendResultString(PlayerInfo player, string result)
  {
    if (!player) { return; }
    CVar messageCVar = CVar.GetCVar("m8f_wm_ResultString", player);
    messageCVar.SetString(result);
  }

  static void SendResultInt(PlayerInfo player, int result)
  {
    if (!player) { return; }
    CVar messageCVar = CVar.GetCVar("m8f_wm_ResultInt", player);
    messageCVar.SetInt(result);
  }

  static void SetZoomFactor(Actor activator
                            , double zoom
                            , string weaponClass
                            , bool lowerWeapon
                            , bool isZoomed
                            , bool changeZoom)
  {
    if (!activator) { return; }

    Weapon w = Weapon(activator.FindInventory(weaponClass));
    if (!w) { return; }

    if (changeZoom)
    {
      zoom = 1 / clamp(zoom, 0.1, 50.0);
      w.FOVScale = zoom;
    }

    if (lowerWeapon)
    {
      int yShift = 16;
      if (!isZoomed) { w.YAdjust -= yShift; }
      else           { w.YAdjust += yShift; }
    }
  }

  static void SetFov(Actor activator, double fov)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    player.SetFov(fov);
  }

  static void GetFov(Actor activator)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    SendResultInt(player, player.FOV);
  }

  static void GiveMinAmmo(Actor activator, string weaponClass)
  {
    if (!activator) { return; }

    Weapon w = Weapon(activator.FindInventory(weaponClass));
    if (!w) { return; }

    Ammo amm1 = w.Ammo1;
    int use = w.AmmoUse1;
    if (amm1) { activator.GiveInventory(amm1.GetClassName(), use); }
  }

  static string SeparateCamelCase(string source)
  {
    int sourceLength = source.Length();
    string result = "";
    string letter1 = source.CharAt(0);
    string letter2;

    for (int i = 1; i < sourceLength; ++i)
    {
      letter2 = source.CharAt(i);
      if (IsSmallLetter(letter1) && IsBigLetter(letter2))
      {
        result.AppendFormat("%s ", letter1);
      }
      else
      {
        result.AppendFormat(letter1);
      }
      letter1 = letter2;
    }
    result.AppendFormat(letter2);

    return result;
  }

  static bool IsSmallLetter(string letter)
  {
    int code = letter.CharCodeAt(0);
    return (97 <= code && code <= 122);
  }

  static bool IsBigLetter(string letter)
  {
    int code = letter.CharCodeAt(0);
    return (65 <= code && code <= 90);
  }

  static void GetWeaponIcon(Actor activator, string weaponClass)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    weaponClass.ToLower();

    string specialIcon = m8f_wm_Data.get().icons.get(weaponClass);
    if (specialIcon.Length() != 0)
    {
      SendResultString(player, specialIcon);
      return;
    }

    string placeholder = "NOWEAPONOFF";
    Weapon w = Weapon(activator.FindInventory(weaponClass));
    if (!w)
    {
      SendResultString(player, placeholder);
      return;
    }

    TextureID iconID = w.SpawnState.GetSpriteTexture(0);
    string icon = TexMan.GetName(iconID);
    if (icon == "TNT1A0") { icon = placeholder; }
    SendResultString(player, icon);
  }

  static void GetAimPitch(Actor activator)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    double slope = activator.BulletSlope(null, ALF_PORTALRESTRICT);
    //Console.Printf("%d", slope);
    SendResultInt(player, slope);
  }

  static void TargetIsPresent(Actor activator)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    Actor target    = activator.AimTarget();
    bool  isPresent = (target != null);
    SendResultInt(player, isPresent);
  }
}

class m8f_wm_StringMap
{
  Array<string> keys;
  Array<string> values;

  void print()
  {
    uint size = values.size();
    Console.Printf("Size: %d", size);
    for (int i = 0; i < size; ++i)
      {
        Console.Printf("%s: %s", keys[i], values[i]);
      }
  }

  void push(string key, string value)
  {
    // array is sorted
    uint size = values.size();
    uint i    = 0;
    for (; i < size && keys[i] < key; ++i);
    keys.insert(i, key);
    values.insert(i, value);
  }

  string get(string key)
  {
    // binary search
    int size = values.size();
    int L    = 0;
    int R    = size - 1;

    while (L <= R)
      {
        int m = (L + R) / 2;
        string current = keys[m];
        if      (current <  key) { L = m + 1; }
        else if (current >  key) { R = m - 1; }
        else if (current == key) { return values[m]; }
      }
    return "";
  }
}

class m8f_wm_Data : Thinker
{
  m8f_wm_StringMap icons;

  static m8f_wm_Data get()
  {
    let it = ThinkerIterator.Create("m8f_wm_Data", STAT_INFO);
    let p  = m8f_wm_Data(it.Next());

    if (p != null) { return p; }
    else           { return new("m8f_wm_Data").init(); }
  }

  m8f_wm_Data init()
  {
    icons = new("m8f_wm_StringMap");

    icons.push("abortbutton"            , "nutpa0_off"  );
    icons.push("argfist"                , "wmbrassoff"  );
    icons.push("artifact"               , "bskla0"      );
    icons.push("bd_chainsaw"            , "csawa0"      );
    icons.push("bd_fist"                , "wmbrassoff"  );
    icons.push("cfsfists"               , "wmbrassoff"  );
    icons.push("cynetikstrikercannon"   , "csgiconoff"  );
    icons.push("d3ps"                   , "pista0"      );
    icons.push("darkmattergun"          , "dmgiconoff"  );
    icons.push("det_pipebomb"           , "scdsa0"      );
    icons.push("det_satchelcharge"      , "pdeta0"      );
    icons.push("doubleknuckles"         , "wmbrassoff"  );
    icons.push("erifist"                , "wmbrassoff"  );
    icons.push("fdaliensbfg9000"        , "abfgz0"      );
    icons.push("fdalienschaingun"       , "achgz0"      );
    icons.push("fdalienschainsaw"       , "asawz0"      );
    icons.push("fdaliensfist"           , "afisz0"      );
    icons.push("fdalienspistol"         , "apisz0"      );
    icons.push("fdaliensplasmarifle"    , "aplaz0"      );
    icons.push("fdaliensrocketlauncher" , "arokz0"      );
    icons.push("fdaliensshotgun"        , "ashtz0"      );
    icons.push("fdalienssupershotgun"   , "assgz0"      );
    icons.push("fdbtsxbfg9000"          , "xbfgz0"      );
    icons.push("fdbtsxchaingun"         , "xchgz0"      );
    icons.push("fdbtsxchainsaw"         , "xsawz0"      );
    icons.push("fdbtsxfist"             , "xfisz0"      );
    icons.push("fdbtsxpistol"           , "xpisz0"      );
    icons.push("fdbtsxplasmarifle"      , "xplaz0"      );
    icons.push("fdbtsxrocketlauncher"   , "xrokz0"      );
    icons.push("fdbtsxshotgun"          , "xshtz0"      );
    icons.push("fdbtsxsupershotgun"     , "xssgz0"      );
    icons.push("fddoom2bfg9000"         , "dbfgz0"      );
    icons.push("fddoom2chaingun"        , "dchgz0"      );
    icons.push("fddoom2chainsaw"        , "dsawz0"      );
    icons.push("fddoom2fist"            , "dfisz0"      );
    icons.push("fddoom2pistol"          , "dpisz0"      );
    icons.push("fddoom2plasmarifle"     , "dplaz0"      );
    icons.push("fddoom2rocketlauncher"  , "drokz0"      );
    icons.push("fddoom2shotgun"         , "dshtz0"      );
    icons.push("fddoom2supershotgun"    , "dssgz0"      );
    icons.push("fdjpcpbfg9000"          , "jbfgz0"      );
    icons.push("fdjpcpchaingun"         , "jchgz0"      );
    icons.push("fdjpcpfist"             , "jfisz0"      );
    icons.push("fdjpcppistol"           , "jpisz0"      );
    icons.push("fdjpcpplasmarifle"      , "jplaz0"      );
    icons.push("fdjpcprocketlauncher"   , "jrokz0"      );
    icons.push("fdjpcpshotgun"          , "jshtz0"      );
    icons.push("fdjpcpsupershotgun"     , "jssgz0"      );
    icons.push("fdplutbfg9000"          , "pbfgz0"      );
    icons.push("fdplutchaingun"         , "pchgz0"      );
    icons.push("fdplutchainsaw"         , "psawz0"      );
    icons.push("fdplutfist"             , "pfisz0"      );
    icons.push("fdplutpistol"           , "ppisz0"      );
    icons.push("fdplutplasmarifle"      , "pplaz0"      );
    icons.push("fdplutrocketlauncher"   , "prokz0"      );
    icons.push("fdplutshotgun"          , "pshtz0"      );
    icons.push("fdplutsupershotgun"     , "pssgz0"      );
    icons.push("fdtntbfg9000"           , "tbfgz0"      );
    icons.push("fdtntchaingun"          , "tchgz0"      );
    icons.push("fdtntchainsaw"          , "tsawz0"      );
    icons.push("fdtntfist"              , "tfisz0"      );
    icons.push("fdtntpistol"            , "tpisz0"      );
    icons.push("fdtntplasmarifle"       , "tplaz0"      );
    icons.push("fdtntrocketlauncher"    , "trokz0"      );
    icons.push("fdtntshotgun"           , "tshtz0"      );
    icons.push("fdtntsupershotgun"      , "tssgz0"      );
    icons.push("fist"                   , "wmbrassoff"  );
    icons.push("fistfixed"              , "wmbrassoff"  );
    icons.push("fkfist"                 , "wmbrassoff"  );
    icons.push("knuckles"               , "wmbrassoff"  );
    icons.push("lewd"                   , "finga0_off"  );
    icons.push("melee"                  , "wmbrassoff"  );
    icons.push("perkfist"               , "wmbrassoff"  );
    icons.push("pkfist"                 , "wmbrassoff"  );
    icons.push("pumpshotgun"            , "kssga0"      );
    icons.push("q3bfg10k"               , "bfgiconoff"  );
    icons.push("q3chaingun"             , "cgiconoff"   );
    icons.push("q3gauntlet"             , "gticonoff"   );
    icons.push("q3grenadelauncher"      , "gliconoff"   );
    icons.push("q3lightninggun"         , "lgiconoff"   );
    icons.push("q3machinegun"           , "mgiconoff"   );
    icons.push("q3nailgun"              , "ngiconoff"   );
    icons.push("q3plasmagun"            , "pgiconoff"   );
    icons.push("q3railgun"              , "rgiconoff"   );
    icons.push("q3rocketlauncher"       , "rliconoff"   );
    icons.push("q3shotgun"              , "sgiconoff"   );
    icons.push("qlheavymachinegun"      , "hmgiconoff"  );
    icons.push("staff"                  , "wmstaff_off" );
    icons.push("trakioncannon"          , "trkiconoff"  );
    icons.push("weapon_357"             , "hpkup102off" );
    icons.push("weapon_9mmar"           , "hpkup103off" );
    icons.push("weapon_crossbow"        , "hpkup109off" );
    icons.push("weapon_crowbar"         , "hpkup100off" );
    icons.push("weapon_egon"            , "hpkup112off" );
    icons.push("weapon_gauss"           , "hpkup111off" );
    icons.push("weapon_glock"           , "hpkup101off" );
    icons.push("weapon_handgrenade"     , "hpkup105off" );
    icons.push("weapon_hornetgun"       , "hpkup113off" );
    icons.push("weapon_rpg"             , "hpkup110off" );
    icons.push("weapon_satchel"         , "hpkup106off" );
    icons.push("weapon_shotgun"         , "hpkup104off" );
    icons.push("weapon_snark"           , "hpkup108off" );
    icons.push("weapon_tripmine"        , "hpkup107off" );
    icons.push("xtremefist"             , "wmbrassoff"  );
    icons.push("xtremesaw"              , "csawa0"      );
    icons.push("z-gun"                  , "hxzgunoff"   );
    icons.push("chainsaw_rekkr"         , "csawa0"      );
    icons.push("plasmarifle_rekkr"      , "plasa0"      );
    icons.push("bfg9000_rekkr"          , "bfuga0"      );
    icons.push("rocketlauncher_rekkr"   , "launa0"      );
    icons.push("chaingun_rekkr"         , "mguna0"      );
    icons.push("shotgun_rekkr"          , "shota0"      );
    icons.push("pistol_rekkr"           , "wmrbow_off"  );
    icons.push("fist_rekkr"             , "wmrfists_off");
    icons.push("64_fist"                , "wmbrassoff"  );

    return self;
  }

}
