class WMZscriptHelper : Actor
{
  static void TellAmmo(Actor activator, string weaponClass, bool showSecond)
  {
    if (!activator) { return; }
    PlayerInfo player = activator.player;
    if (!player) { return; }

    Weapon w = Weapon(activator.FindInventory(weaponClass));
    if (!w)
    {
      SendResultString(player, "");
      return;
    }

    string message = "";

    Ammo amm1 = w.Ammo1;
    if (amm1)
    {
      message = String.Format("%d/%d", amm1.amount, amm1.maxAmount);
    }

    Ammo amm2 = w.Ammo2;
    if (showSecond && amm2 && amm1 != amm2)
    {
      message = String.Format("%s - %d/%d", message, amm2.amount, amm2.maxAmount);
    }

    SendResultString(player, message);
  }

  static void HasAmmo(Actor activator, string weaponClass)
  {
    if (!activator) { return; }
    PlayerInfo player = activator.player;
    if (!player) { return; }

    Weapon w = Weapon(activator.FindInventory(weaponClass));
    if (!w)
    {
      SendResultInt(player, 0);
      return;
    }

    bool result = true;
    Ammo amm1 = w.Ammo1;
    Ammo amm2 = w.Ammo2;
    bool hasAmmo1 = (amm1 != null);
    bool hasAmmo2 = (amm2 != null);

    if (!hasAmmo1 && !hasAmmo2) { result = true; }
    else
    {
      if (hasAmmo1) { result  = amm1.amount >= w.AmmoUse1; }
      if (hasAmmo2) { result |= amm2.amount >= w.AmmoUse2; }
    }

    SendResultInt(player, result);
  }

  static void IsWeaponReady(Actor activator, string weaponClass)
  {
    if (!activator) { return; }
    PlayerInfo player = activator.player;
    if (!player) { return; }

    bool isReady = (player.WeaponState & WF_WEAPONREADY)
      || (player.WeaponState & WF_WEAPONREADYALT);
    SendResultInt(player, isReady);
  }

  static void IsWeaponDeselectable(Actor activator, string weaponClass)
  {
    if (!activator) { return; }
    PlayerInfo player = activator.player;
    if (!player) { return; }

    bool isDeselectable = player.WeaponState & WF_WEAPONSWITCHOK;
    SendResultInt(player, isDeselectable);
  }

  static void IsWeaponBeingDeselected(Actor activator)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    bool isDeselected = player.PendingWeapon.GetClassName() != "Object";
    SendResultInt(player, isDeselected);
  }

  static void FireWeapon(Actor activator, string weaponClass)
  {
    if (!activator) { return; }

    PlayerPawn pawn = PlayerPawn(activator);
    pawn.FireWeapon(null);
  }

  static void FireWeaponAlt(Actor activator, string weaponClass)
  {
    if (!activator) { return; }

    PlayerPawn pawn = PlayerPawn(activator);
    pawn.FireWeaponAlt(null);
  }

  static void HolsterWeapon(Actor activator)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    player.PendingWeapon = null;
  }

  static void GetInventoryList(Actor activator)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    string inventoryContents = "";
    int nClasses = AllActorClasses.Size();

    for (int i = 0; i < nClasses; ++i)
    {
      let type = (class<Inventory>)(AllActorClasses[i]);
      if (type == null) { continue; }

      readonly<Inventory> inv = GetDefaultByType(type);
      if (!inv.bINVBAR || inv.bAUTOACTIVATE) { continue; }

      string className = inv.GetClassName();
      string tag       = SeparateCamelCase(inv.GetTag());
      inventoryContents.AppendFormat("%s>%s>", className, tag);
    }

    SendResultString(player, inventoryContents);
  }

  static void GetInventoryTag(Actor activator, string itemClass)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    class<Inventory> type = itemClass;
    if (!type)
    {
      Console.Printf("Unknown inventory type: %s", itemClass);
      SendResultString(player, "unknown");
      return;
    }

    readonly<Inventory> defaultItem = GetDefaultByType(type);
    if (!defaultItem)
    {
      Console.Printf("Unknown inventory type: %s", itemClass);
      SendResultString(player, "unknown");
      return;
    }

    string tag = defaultItem.GetTag();

    SendResultString(player, tag);
  }

  static void GetSelectedInventory(Actor activator)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    PlayerPawn pawn = PlayerPawn(activator);

    if (pawn && pawn.InvSel != null)
    {
      SendResultString(player, pawn.InvSel.GetClassName());
    }
    else
    {
      SendResultString(player, "wm_none");
    }
  }

  static void SetSelectedInventory(Actor activator, string itemClass)
  {
    if (!activator) { return; }

    PlayerPawn pawn = PlayerPawn(activator);
    pawn.InvSel = pawn.FindInventory(itemClass);
  }

  static void GetWeaponList(Actor activator)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    string weaponData = "";
    int nClasses = AllActorClasses.Size();

    for (int i = 0; i < nClasses; ++i)
    {
      let type = (class<Weapon>)(AllActorClasses[i]);
      if (type != null && type != "Weapon")
      {
        let rep = GetReplacement(type);
        // Don't give replaced weapons unless the replacement was done by Dehacked.
        if (rep == type || rep is "DehackedPickup")
        {
          // List the weapon only if it is set in a weapon slot.
          int slot;
          int located;
          int priority;
          [located, slot, priority] = player.weapons.LocateWeapon(type);
          if (located)
          {
            readonly<Weapon> def = GetDefaultByType(type);
            if (!def.CanPickup(activator)) { continue; }

            string tag = SeparateCamelCase(def.GetTag());
            tag.Replace("_", " ");

            string className = type.GetClassName();

            // just to be sure that "serializing" will not break
            tag.Replace(">", " ");
            className.Replace(">", " ");

            weaponData.AppendFormat("%s>%s>%d>%d>", className, tag, slot, priority);
          }
        }
      }
    }

    SendResultString(player, weaponData);
  }

  static void SendResultString(PlayerInfo player, string result)
  {
    if (!player) { return; }
    CVar messageCVar = CVar.GetCVar("m8f_wm_ResultString", player);
    messageCVar.SetString(result);
  }

  static void SendResultInt(PlayerInfo player, int result)
  {
    if (!player) { return; }
    CVar messageCVar = CVar.GetCVar("m8f_wm_ResultInt", player);
    messageCVar.SetInt(result);
  }

  static void SetZoomFactor(Actor activator
                            , double zoom
                            , string weaponClass
                            , bool lowerWeapon
                            , bool isZoomed
                            , bool changeZoom)
  {
    if (!activator) { return; }

    Weapon w = Weapon(activator.FindInventory(weaponClass));
    if (!w) { return; }

    if (changeZoom)
    {
      zoom = 1 / clamp(zoom, 0.1, 50.0);
      w.FOVScale = zoom;
    }

    if (lowerWeapon)
    {
      int yShift = 16;
      if (!isZoomed) { w.YAdjust -= yShift; }
      else           { w.YAdjust += yShift; }
    }
  }

  static void GiveThisAmmo(Actor activator, string weaponClass)
  {
    if (!activator) { return; }

    Weapon w = Weapon(activator.FindInventory(weaponClass));
    if (!w) { return; }

    Ammo amm1 = w.Ammo1;
    Ammo amm2 = w.Ammo2;
    if (amm1) { activator.GiveInventory(amm1.GetClassName(), 10); }
    if (amm2) { activator.GiveInventory(amm2.GetClassName(), 10); }
  }

  static void GiveMinAmmo(Actor activator, string weaponClass)
  {
    if (!activator) { return; }

    Weapon w = Weapon(activator.FindInventory(weaponClass));
    if (!w) { return; }

    Ammo amm1 = w.Ammo1;
    int use = w.AmmoUse1;
    if (amm1) { activator.GiveInventory(amm1.GetClassName(), use); }
  }

  static string SeparateCamelCase(string source)
  {
    int sourceLength = source.Length();
    string result = "";
    string letter1 = source.CharAt(0);
    string letter2;

    for (int i = 1; i < sourceLength; ++i)
    {
      letter2 = source.CharAt(i);
      if (IsSmallLetter(letter1) && IsBigLetter(letter2))
      {
        result.AppendFormat("%s ", letter1);
      }
      else
      {
        result.AppendFormat(letter1);
      }
      letter1 = letter2;
    }
    result.AppendFormat(letter2);

    return result;
  }

  static bool IsSmallLetter(string letter)
  {
    int code = letter.CharCodeAt(0);
    return (97 <= code && code <= 122);
  }

  static bool IsBigLetter(string letter)
  {
    int code = letter.CharCodeAt(0);
    return (65 <= code && code <= 90);
  }

  static void GetWeaponIcon(Actor activator, string weaponClass)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    // must be sorted!
    // don't forget to update size!
    // must be in lower case!
    static const string specialIcons[] =
    {
      "abortbutton", "nutpa0_off",
      "argfist" , "wmbrassoff",
      "artifact", "bskla0",
      "bd_chainsaw", "csawa0",
      "bd_fist" , "wmbrassoff",
      "cfsfists", "wmbrassoff",
      "cynetikstrikercannon", "csgiconoff",
      "d3ps"    , "pista0",
      "darkmattergun", "dmgiconoff",
      "det_pipebomb"     , "scdsa0",
      "det_satchelcharge", "pdeta0",
      "doubleknuckles", "wmbrassoff",
      "erifist" , "wmbrassoff",
      "fdaliensbfg9000"        , "abfgz0",
      "fdalienschaingun"       , "achgz0",
      "fdalienschainsaw"       , "asawz0",
      "fdaliensfist"           , "afisz0",
      "fdalienspistol"         , "apisz0",
      "fdaliensplasmarifle"    , "aplaz0",
      "fdaliensrocketlauncher" , "arokz0",
      "fdaliensshotgun"        , "ashtz0",
      "fdalienssupershotgun"   , "assgz0",
      "fdbtsxbfg9000"        , "xbfgz0",
      "fdbtsxchaingun"       , "xchgz0",
      "fdbtsxchainsaw"       , "xsawz0",
      "fdbtsxfist"           , "xfisz0",
      "fdbtsxpistol"         , "xpisz0",
      "fdbtsxplasmarifle"    , "xplaz0",
      "fdbtsxrocketlauncher" , "xrokz0",
      "fdbtsxshotgun"        , "xshtz0",
      "fdbtsxsupershotgun"   , "xssgz0",
      "fddoom2bfg9000"        , "dbfgz0",
      "fddoom2chaingun"       , "dchgz0",
      "fddoom2chainsaw"       , "dsawz0",
      "fddoom2fist"           , "dfisz0",
      "fddoom2pistol"         , "dpisz0",
      "fddoom2plasmarifle"    , "dplaz0",
      "fddoom2rocketlauncher" , "drokz0",
      "fddoom2shotgun"        , "dshtz0",
      "fddoom2supershotgun"   , "dssgz0",
      "fdjpcpbfg9000"        , "jbfgz0",
      "fdjpcpchaingun"       , "jchgz0",
      "fdjpcpfist"           , "jfisz0",
      "fdjpcppistol"         , "jpisz0",
      "fdjpcpplasmarifle"    , "jplaz0",
      "fdjpcprocketlauncher" , "jrokz0",
      "fdjpcpshotgun"        , "jshtz0",
      "fdjpcpsupershotgun"   , "jssgz0",
      "fdplutbfg9000"       , "pbfgz0",
      "fdplutchaingun"      , "pchgz0",
      "fdplutchainsaw"      , "psawz0",
      "fdplutfist"          , "pfisz0",
      "fdplutpistol"        , "ppisz0",
      "fdplutplasmarifle"   , "pplaz0",
      "fdplutrocketlauncher", "prokz0",
      "fdplutshotgun"       , "pshtz0",
      "fdplutsupershotgun"  , "pssgz0",
      "fdtntbfg9000"        , "tbfgz0",
      "fdtntchaingun"       , "tchgz0",
      "fdtntchainsaw"       , "tsawz0",
      "fdtntfist"           , "tfisz0",
      "fdtntpistol"         , "tpisz0",
      "fdtntplasmarifle"    , "tplaz0",
      "fdtntrocketlauncher" , "trokz0",
      "fdtntshotgun"        , "tshtz0",
      "fdtntsupershotgun"   , "tssgz0",
      "fist"      , "wmbrassoff",
      "fistfixed" , "wmbrassoff",
      "fkfist"    , "wmbrassoff",
      "knuckles"  , "wmbrassoff",
      "lewd", "finga0_off",
      "melee"     , "wmbrassoff",
      "perkfist"  , "wmbrassoff",
      "pkfist"    , "wmbrassoff",
      "pumpshotgun", "kssga0",
      "q3bfg10k"         , "bfgiconoff",
      "q3chaingun"       , "cgiconoff",
      "q3gauntlet"       , "gticonoff",
      "q3grenadelauncher", "gliconoff",
      "q3lightninggun"   , "lgiconoff",
      "q3machinegun"     , "mgiconoff",
      "q3nailgun"        , "ngiconoff",
      "q3plasmagun"      , "pgiconoff",
      "q3railgun"        , "rgiconoff",
      "q3rocketlauncher" , "rliconoff",
      "q3shotgun"        , "sgiconoff",
      "qlheavymachinegun", "hmgiconoff",
      "trakioncannon"    , "trkiconoff",
      "weapon_357"        , "hpkup102off",
      "weapon_9mmar"      , "hpkup103off",
      "weapon_crossbow"   , "hpkup109off",
      "weapon_crowbar"    , "hpkup100off",
      "weapon_egon"       , "hpkup112off",
      "weapon_gauss"      , "hpkup111off",
      "weapon_glock"      , "hpkup101off",
      "weapon_handgrenade", "hpkup105off",
      "weapon_hornetgun"  , "hpkup113off",
      "weapon_rpg"        , "hpkup110off",
      "weapon_satchel"    , "hpkup106off",
      "weapon_shotgun"    , "hpkup104off",
      "weapon_snark"      , "hpkup108off",
      "weapon_tripmine"   , "hpkup107off",
      "xtremefist", "wmbrassoff",
      "z-gun", "hxzgunoff"
    };

    int size = 104;

    weaponClass.ToLower();

    // binary search
    int L = 0;
    int R = size - 1;
    while (L <= R)
    {
      int m = (L + R) / 2;
      string current = specialIcons[m * 2];
      //Console.Printf("%d - %s vs %s", m, current, weaponClass);
      if      (current <  weaponClass) { L = m + 1; continue; }
      else if (current >  weaponClass) { R = m - 1; continue; }
      else if (current == weaponClass)
      {
        SendResultString(player, specialIcons[m * 2 + 1]);
        return;
      }
    }

    string placeholder = "NOWEAPONOFF";
    Weapon w = Weapon(activator.FindInventory(weaponClass));
    if (!w)
    {
      SendResultString(player, placeholder);
      return;
    }

    TextureID iconID = w.SpawnState.GetSpriteTexture(0);
    string icon = TexMan.GetName(iconID);
    if (icon == "TNT1A0") { icon = placeholder; }
    SendResultString(player, icon);
  }
}

class WM_Lighter : Actor
{
  string checkedWeapon;

  Default
  {
    +NOGRAVITY;
  }

  States
  {
  Spawn:
    TNT1 A 0;
    TNT1 A 0 a_jumpifinventory(checkedWeapon, 1, "NoLight", AAPTR_PLAYER1);
  Light:
    TNT1 A 10;// A_Log("light");
    goto Spawn;
  NoLight:
    TNT1 B 35;// A_Log("no light");
    loop;
  }
}
