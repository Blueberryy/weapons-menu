class WMZscriptHelper : Actor
{
  static void TellAmmo(Actor activator, string weaponClass, bool showSecond)
  {
    if (!activator || !activator.player)
    {
      SendResultString(activator, "");
      return;
    }

    Weapon w = Weapon(activator.FindInventory(weaponClass));
    if (!w)
    {
      SendResultString(activator, "");
      return;
    }

    string message = "";

    Ammo amm1 = w.Ammo1;
    if (amm1)
    {
      message = String.Format("%d/%d", amm1.amount, amm1.maxAmount);
    }

    Ammo amm2 = w.Ammo2;
    if (showSecond && amm2 && amm1 != amm2)
    {
      message = String.Format("%s - %d/%d", message, amm2.amount, amm2.maxAmount);
    }

    SendResultString(activator, message);
  }

  static void IsWeaponReady(Actor activator, string weaponClass)
  {
    PlayerPawn p = PlayerPawn(activator);
    bool isReady = (p.player.WeaponState & WF_WEAPONREADY)
      || (p.player.WeaponState & WF_WEAPONREADYALT);
    SendResultInt(activator, isReady);
  }

  static void IsWeaponDeselectable(Actor activator, string weaponClass)
  {
    PlayerPawn p = PlayerPawn(activator);
    bool isDeselectable = p.player.WeaponState & WF_WEAPONSWITCHOK;
    SendResultInt(activator, isDeselectable);
  }

  static void IsWeaponBeingDeselected(Actor activator)
  {
    if (!activator) { return; }
    let player = activator.player;
    if (!player) { return; }

    bool isDeselected = player.PendingWeapon.GetClassName() != "Object";
    SendResultInt(activator, isDeselected);
  }

  static void FireWeapon(Actor activator, string weaponClass)
  {
    if (!activator || !activator.player) { return; }

    PlayerPawn p = PlayerPawn(activator);
    p.FireWeapon(null);
  }

  static void FireWeaponAlt(Actor activator, string weaponClass)
  {
    if (!activator || !activator.player) { return; }

    PlayerPawn p = PlayerPawn(activator);
    p.FireWeaponAlt(null);
  }

  static void HolsterWeapon(Actor activator)
  {
    if (!activator || !activator.player) { return; }

    activator.player.PendingWeapon = null;
  }

  static void GetInventoryList(Actor activator)
  {
    if (!activator || !activator.player) { return; }

    string inventoryContents = "";
    int nClasses = AllActorClasses.Size();

    for (int i = 0; i < nClasses; ++i)
    {
      let type = (class<Inventory>)(AllActorClasses[i]);
      if (type == null) { continue; }

      readonly<Inventory> inv = GetDefaultByType(type);
      if (!inv.bINVBAR || inv.bAUTOACTIVATE) { continue; }

      string className = inv.GetClassName();
      string tag       = SeparateCamelCase(inv.GetTag());
      inventoryContents.AppendFormat("%s>%s>", className, tag);
    }

    SendResultString(activator, inventoryContents);
  }

  static void GetInventoryTag(Actor activator, string itemClass)
  {
    if (!activator) { return; }
    string tag = activator.FindInventory(itemClass).GetTag();
    SendResultString(activator, tag);
  }

  static void GetSelectedInventory(Actor activator)
  {
    if (!activator || !activator.player) { return; }
    PlayerPawn player = PlayerPawn(activator);
    if (player.InvSel != null)
    {
      SendResultString(activator, player.InvSel.GetClassName());
    }
    else
    {
      SendResultString(activator, "wm_none");
    }
  }

  static void SetSelectedInventory(Actor activator, string itemClass)
  {
    if (!activator || !activator.player) { return; }
    PlayerPawn player = PlayerPawn(activator);
    player.InvSel = player.FindInventory(itemClass);
  }

  static void GetWeaponList(Actor activator)
  {
    PlayerInfo player = activator.player;
    if (!activator || !player) { return; }

    string weaponData = "";
    int nClasses = AllActorClasses.Size();

    for (int i = 0; i < nClasses; ++i)
    {
      let type = (class<Weapon>)(AllActorClasses[i]);
      if (type != null && type != "Weapon")
      {
        let rep = GetReplacement(type);
        // Don't give replaced weapons unless the replacement was done by Dehacked.
        if (rep == type || rep is "DehackedPickup")
        {
          // List the weapon only if it is set in a weapon slot.
          int slot;
          int located;
          int priority;
          [located, slot, priority] = player.weapons.LocateWeapon(type);
          if (located)
          {
            readonly<Weapon> def = GetDefaultByType(type);
            string tag           = SeparateCamelCase(def.GetTag());
            string className     = type.GetClassName();
            weaponData.AppendFormat("%s>%s>%d>%d>", className, tag, slot, priority);
          }
        }
      }
    }

    SendResultString(activator, weaponData);
  }

  static void SendResultString(Actor a, string result)
  {
    CVar messageCVar = CVar.GetCVar("m8f_wm_ResultString", a.player);
    messageCVar.SetString(result);
  }

  static void SendResultInt(Actor a, int result)
  {
    CVar messageCVar = CVar.GetCVar("m8f_wm_ResultInt", a.player);
    messageCVar.SetInt(result);
  }

  static void SetZoomFactor(Actor activator
                            , double zoom
                            , string weaponClass
                            , bool lowerWeapon
                            , bool isZoomed)
  {
    if (!activator) { return; }
    let player = activator.player;

    Weapon w = Weapon(activator.FindInventory(weaponClass));
    if (!w) { return; }

    zoom = 1 / clamp(zoom, 0.1, 50.0);

    w.FOVScale = zoom;

    if (lowerWeapon)
    {
      int yShift = 16;
      if (!isZoomed) { w.YAdjust -= yShift; }
      else           { w.YAdjust += yShift; }
    }
  }

  static void GiveThisAmmo(Actor activator, string weaponClass)
  {
    if (!activator || !activator.player) { return; }

    Weapon w = Weapon(activator.FindInventory(weaponClass));
    if (!w) { return; }

    Ammo amm1 = w.Ammo1;
    Ammo amm2 = w.Ammo2;
    if (amm1) { activator.GiveInventory(amm1.GetClassName(), 10); }
    if (amm2) { activator.GiveInventory(amm2.GetClassName(), 10); }
  }

  static void GiveMinAmmo(Actor activator, string weaponClass)
  {
    if (!activator || !activator.player) { return; }

    Weapon w = Weapon(activator.FindInventory(weaponClass));
    if (!w) { return; }

    Ammo amm1 = w.Ammo1;
    int use = w.AmmoUse1;
    if (amm1) { activator.GiveInventory(amm1.GetClassName(), use); }
  }

  static string SeparateCamelCase(string source)
  {
    int sourceLength = source.Length();
    string result = "";
    string letter1 = source.CharAt(0);
    string letter2;

    for (int i = 1; i < sourceLength; ++i)
    {
      letter2 = source.CharAt(i);
      if (IsSmallLetter(letter1) && IsBigLetter(letter2))
      {
        result.AppendFormat("%s ", letter1);
      }
      else
      {
        result.AppendFormat(letter1);
      }
      letter1 = letter2;
    }
    result.AppendFormat(letter2);

    return result;
  }

  static bool IsSmallLetter(string letter)
  {
    int code = letter.CharCodeAt(0);
    return (97 <= code && code <= 122);
  }

  static bool IsBigLetter(string letter)
  {
    int code = letter.CharCodeAt(0);
    return (65 <= code && code <= 90);
  }

  static void GetWeaponIcon(Actor a, string weaponClass)
  {
    if (!a) { return; }

    // must be sorted!
    // don't forget to update size!
    // must be in lower case!
    static const string specialIcons[] =
    {
      "argfist" , "wmbrassoff",
      "artifact", "bskla0",
      "bd_chainsaw", "csawa0",
      "bd_fist" , "wmbrassoff",
      "cfsfists", "wmbrassoff",
      "d3ps"    , "pista0",
      "det_pipebomb"     , "scdsa0",
      "det_satchelcharge", "pdeta0",
      "doubleknuckles", "wmbrassoff",
      "erifist" , "wmbrassoff",
      "fdaliensbfg9000"        , "abfgz0",
      "fdalienschaingun"       , "achgz0",
      "fdalienschainsaw"       , "asawz0",
      "fdaliensfist"           , "afisz0",
      "fdalienspistol"         , "apisz0",
      "fdaliensplasmarifle"    , "aplaz0",
      "fdaliensrocketlauncher" , "arokz0",
      "fdaliensshotgun"        , "ashtz0",
      "fdalienssupershotgun"   , "assgz0",
      "fdbtsxbfg9000"        , "xbfgz0",
      "fdbtsxchaingun"       , "xchgz0",
      "fdbtsxchainsaw"       , "xsawz0",
      "fdbtsxfist"           , "xfisz0",
      "fdbtsxpistol"         , "xpisz0",
      "fdbtsxplasmarifle"    , "xplaz0",
      "fdbtsxrocketlauncher" , "xrokz0",
      "fdbtsxshotgun"        , "xshtz0",
      "fdbtsxsupershotgun"   , "xssgz0",
      "fddoom2bfg9000"        , "dbfgz0",
      "fddoom2chaingun"       , "dchgz0",
      "fddoom2chainsaw"       , "dsawz0",
      "fddoom2fist"           , "dfisz0",
      "fddoom2pistol"         , "dpisz0",
      "fddoom2plasmarifle"    , "dplaz0",
      "fddoom2rocketlauncher" , "drokz0",
      "fddoom2shotgun"        , "dshtz0",
      "fddoom2supershotgun"   , "dssgz0",
      "fdjpcpbfg9000"        , "jbfgz0",
      "fdjpcpchaingun"       , "jchgz0",
      "fdjpcpfist"           , "jfisz0",
      "fdjpcppistol"         , "jpisz0",
      "fdjpcpplasmarifle"    , "jplaz0",
      "fdjpcprocketlauncher" , "jrokz0",
      "fdjpcpshotgun"        , "jshtz0",
      "fdjpcpsupershotgun"   , "jssgz0",
      "fdplutbfg9000"       , "pbfgz0",
      "fdplutchaingun"      , "pchgz0",
      "fdplutchainsaw"      , "psawz0",
      "fdplutfist"          , "pfisz0",
      "fdplutpistol"        , "ppisz0",
      "fdplutplasmarifle"   , "pplaz0",
      "fdplutrocketlauncher", "prokz0",
      "fdplutshotgun"       , "pshtz0",
      "fdplutsupershotgun"  , "pssgz0",
      "fdtntbfg9000"        , "tbfgz0",
      "fdtntchaingun"       , "tchgz0",
      "fdtntchainsaw"       , "tsawz0",
      "fdtntfist"           , "tfisz0",
      "fdtntpistol"         , "tpisz0",
      "fdtntplasmarifle"    , "tplaz0",
      "fdtntrocketlauncher" , "trokz0",
      "fdtntshotgun"        , "tshtz0",
      "fdtntsupershotgun"   , "tssgz0",
      "fist"      , "wmbrassoff",
      "fistfixed" , "wmbrassoff",
      "fkfist"    , "wmbrassoff",
      "knuckles"  , "wmbrassoff",
      "melee"     , "wmbrassoff",
      "perkfist"  , "wmbrassoff",
      "pkfist"    , "wmbrassoff",
      "pumpshotgun", "kssga0",
      "weapon_357"        , "hpkup102off",
      "weapon_9mmar"      , "hpkup103off",
      "weapon_crossbow"   , "hpkup109off",
      "weapon_crowbar"    , "hpkup100off",
      "weapon_egon"       , "hpkup112off",
      "weapon_gauss"      , "hpkup111off",
      "weapon_glock"      , "hpkup101off",
      "weapon_handgrenade", "hpkup105off",
      "weapon_hornetgun"  , "hpkup113off",
      "weapon_rpg"        , "hpkup110off",
      "weapon_satchel"    , "hpkup106off",
      "weapon_shotgun"    , "hpkup104off",
      "weapon_snark"      , "hpkup108off",
      "weapon_tripmine"   , "hpkup107off",
      "xtremefist", "wmbrassoff",
      "z-gun", "hxzgunoff"
    };

    int size = 87;

    weaponClass.ToLower();

    // binary search
    int L = 0;
    int R = size - 1;
    while (L <= R)
    {
      int m = (L + R) / 2;
      string current = specialIcons[m * 2];
      //Console.Printf("%d - %s vs %s", m, current, weaponClass);
      if      (current <  weaponClass) { L = m + 1; continue; }
      else if (current >  weaponClass) { R = m - 1; continue; }
      else if (current == weaponClass)
      {
        SendResultString(a, specialIcons[m * 2 + 1]);
        return;
      }
    }

    string placeholder = "NOWEAPONOFF";
    Weapon w = Weapon(a.FindInventory(weaponClass));
    if (!w)
    {
      SendResultString(a, placeholder);
      return;
    }

    TextureID iconID = w.SpawnState.GetSpriteTexture(0);
    string icon = TexMan.GetName(iconID);
    if (icon == "TNT1A0") { icon = placeholder; }
    SendResultString(a, icon);
  }
}
