#library "LIBWEAPONMENU"
#include "zcommon.acs"

#include "data.acs"

#define messageIdStart   191919
#define msgIdWeapon      messageIdStart
#define msgIdSlot        messageIdStart + MAX_WEAPONS_NUMBER
#define msgIdSelected    messageIdStart + MAX_WEAPONS_NUMBER * 2
#define msgIdHighlighted messageIdStart + MAX_WEAPONS_NUMBER * 2 + 1
#define msgIdError       messageIdStart + MAX_WEAPONS_NUMBER * 2 + 2
#define msgIdAmmo        messageIdStart + MAX_WEAPONS_NUMBER * 2 + 3
#define msgIdTag         messageIdStart + MAX_WEAPONS_NUMBER * 2 + 4
#define msgIdIcon        messageIdStart + MAX_WEAPONS_NUMBER * 2 + 5
#define msgIdBackground  messageIdStart + MAX_WEAPONS_NUMBER * 2 + 6
#define msgIdBackgroundA messageIdStart + MAX_WEAPONS_NUMBER * 2 + 7
#define msgIdBackgroundB messageIdStart + MAX_WEAPONS_NUMBER * 2 + 8

#define msgFlags HUDMSG_PLAIN | HUDMSG_NOTWITHFULLMAP | HUDMSG_NOTWITHOVERLAYMAP

#define ERROR_NOT_FOUND  -1
// numbers [-1, -9] are reserved for error codes

#define WEAPON_HOLSTERED -10

#define N_QUICK_INVENTORY_ITEMS 10

#define BACKGROUND_LEFT     0
#define BACKGROUND_TOP      1
#define BACKGROUND_RIGHT    2

// Global variables ////////////////////////////////////////////////////////////
// To write to global variables, use only special functions.

#define STATE_UNINITIALIZED  0
#define STATE_TERMINATED     1
#define STATE_ENABLED        2
#define STATE_CLOSED         3
#define STATE_OPENED         4
#define STATE_INVENTORY      5
#define STATE_CLOSED_VISIBLE 6
//
// (UNINITIALIZED) -titlemap-> [TERMINATED]
// (UNINITIALIZED) -always-open-> OPENED
// (UNINITIALIZED) --> CLOSED
//
// CLOSED -open->  OPENED
// OPENED -close-> CLOSED
// OPENED -close-and-always-open-> CLOSED_VISIBLE
//
// CLOSED -open-inventory-> INVENTORY
// OPENED -open-inventory-> INVENTORY
int globalState = 0;

// Global variables. Must be used only in enabled states.

// cached variables. Their values don't change during the game.
int  currentSet;
int  weaponCount;
int  step;

bool isDoom1;
bool isDoom2;
bool isFreedoom1;
bool isFreedoom2;

int  highlightedWeapon;
int  selectedWeapon;
str  lastUsedWeapon;

bool selectedWatchEnabled = true;

bool isInInventory[MAX_WEAPONS_NUMBER];

int zoomFactor = 1.0;
bool isZoomed;

int originalFov;

// Inventory variables section /////////////////////////////////////////////////

int nInventoryItems;

#define N_INVENTORY_ITEMS 250

str inventoryClasses[N_INVENTORY_ITEMS];
str inventoryNames  [N_INVENTORY_ITEMS];

// Get status section //////////////////////////////////////////////////////////

function bool IsUninitialized(void) { return globalState == STATE_UNINITIALIZED; }
function bool IsOpened(void)     { return globalState == STATE_OPENED; }
function bool IsInventory(void)  { return globalState == STATE_INVENTORY; }
function bool IsVisible(void)    { return globalState == STATE_OPENED || globalState == STATE_CLOSED_VISIBLE; }

function bool IsAlwaysShow(int playerN)
{
  bool alwaysShow = GetUserCVar(playerN, "M8fWeaponMenuAlwaysShow");
  return alwaysShow;
}

function int WM_GetInitialState(int playerN)
{
  if (WM_IsTitlemap()) { return STATE_TERMINATED; }

  currentSet = WM_GetWeaponSet(playerN);

  return STATE_ENABLED;
}

// Global state must be changed only with this function.
function void WM_ChangeState(int newState, int playerN)
{
  if (newState == globalState)
  {
    return;
  }

  WM_LeaveState(globalState, playerN);
  WM_EnterState(newState, playerN);
}

function void WM_LeaveState(int oldState, int playerN)
{
  // leave previous state
  switch (oldState)
    {
    case STATE_UNINITIALIZED:  WM_LeaveUninitialized(playerN); break;
    case STATE_TERMINATED:     WM_LeaveTerminated(playerN);    break;
    case STATE_Enabled:        WM_LeaveEnabled(playerN);       break;
    case STATE_CLOSED:         WM_LeaveClosed(playerN);        break;
    case STATE_OPENED:         WM_LeaveOpened(playerN);        break;
    case STATE_INVENTORY:      WM_LeaveInventory(playerN);     break;
    case STATE_CLOSED_VISIBLE: WM_LeaveClosedVisible(playerN); break;
    }
}

function void WM_EnterState(int newState, int playerN)
{
  globalState = newState;
  SetUserCVar(playerN, "M8fWeaponMenuIsEnabled", true);
  SetUserCVar(playerN, "M8fWeaponMenuIsOpened", IsOpened() || IsInventory());

  switch (newState)
    {
    case STATE_UNINITIALIZED:  WM_EnterUninitialized(playerN); break;
    case STATE_TERMINATED:     WM_EnterTerminated(playerN);    break;
    case STATE_Enabled:        WM_EnterEnabled(playerN);       break;
    case STATE_CLOSED:         WM_EnterClosed(playerN);        break;
    case STATE_OPENED:         WM_EnterOpened(playerN);        break;
    case STATE_INVENTORY:      WM_EnterInventory(playerN);     break;
    case STATE_CLOSED_VISIBLE: WM_EnterClosedVisible(playerN); break;
    }
}

function void WM_LeaveUninitialized(int playerN)
{
  if (currentSet == SET_FALLBACK)
  {
    WM_GetFallbackWeapons(playerN);
  }

  WM_MaybeLoadCustomWeaponOrder(playerN);
}

function void WM_LeaveTerminated(int playerN) {}
function void WM_LeaveEnabled(int playerN) {}
function void WM_LeaveClosed(int playerN) {}

function void WM_LeaveOpened(int playerN)
{
  WM_MaybeToggleSlomoOnClose(playerN);
  WM_ClearScreen();
}

function void WM_LeaveInventory(int playerN)
{
  WM_MaybeToggleSlomoOnInvClose(playerN);
  WM_PlaySwitchSound(playerN);
  WM_ClearScreen();
}

function void WM_LeaveClosedVisible(int playerN) {}

function void WM_EnterUninitialized(int playerN) {}

function void WM_EnterTerminated(int playerN) {}

function void WM_EnterEnabled(int playerN)
{
  weaponCount = weaponCounts[currentSet];
  step        = WM_IfThenElse((weaponCount < 20), 0.05, 0.02);
  isDoom1     = WM_IsDoom1();
  isDoom2     = WM_IsDoom2();
  isFreedoom1 = WM_IsFreedoom1();
  isFreedoom2 = WM_IsFreedoom2();

  WM_SetSelectedWeapon(WM_FindRealSelectedWeapon(), playerN);
  WM_SetHighlightedWeapon(selectedWeapon, playerN);

  lastUsedWeapon = WM_Unwrap(GetUserCVarString(playerN, "m8f_wm_LastUsedWeapon"));

  if (!WM_CheckInventory(lastUsedWeapon))
  {
    WM_SetLastUsedWeapon(WM_GetWeaponName(selectedWeapon), playerN);
  }

  WM_SetupAddons(playerN);
  WM_UpdateIsInInventory();
  WM_InitApiCvars(playerN);
  WM_FillInventoryItems(playerN);

  if (IsAlwaysShow(playerN)) { WM_ChangeState(STATE_CLOSED_VISIBLE, playerN); }
  else                       { WM_ChangeState(STATE_CLOSED,         playerN); }
}

function void WM_EnterClosed(int playerN)
{
  if (highlightedWeapon != selectedWeapon)
  {
    WM_SelectWeapon(highlightedWeapon, true, playerN);
  }

  if (IsAlwaysShow(playerN))
  {
    WM_ChangeState(STATE_CLOSED_VISIBLE, playerN);
  }
}

function void WM_EnterOpened(int playerN)
{
  WM_MaybeToggleSlomoOnOpen(playerN);
  WM_UpdateIsInInventory();
  WM_UpdateMenu(playerN);
}

function void WM_EnterInventory(int playerN)
{
  WM_MaybeToggleSlomoOnInvOpen(playerN);
  WM_SetHighlightedWeapon(WM_FindRealSelectedWeapon(), playerN);
  WM_PlaySwitchSound(playerN);
  WM_PrintInventoryMenu(playerN);
}

function void WM_EnterClosedVisible(int playerN)
{
  WM_UpdateIsInInventory();
  WM_UpdateMenu(playerN);
}

function void WM_MaybeLoadCustomWeaponOrder(int playerN)
{
  int previousSet   = GetUserCVar(playerN, "m8f_wm_PreviousWeaponSet");
  int previousCount = GetUserCVar(playerN, "M8fWeaponMenuWeaponCount");

  if (previousSet == currentSet && previousCount == weaponCounts[currentSet])
  {
    if (currentSet != SET_FALLBACK)
    {
      WM_LoadDataFromCVars(playerN);
    }
    else
    {
      str currentPlayerClass  = GetActorClass(0);
      str previousPlayerClass = GetUserCVarString(playerN, "m8f_wm_PreviousPlayerClass");
      bool sameClass = (StrCmp(previousPlayerClass, currentPlayerClass) == 0);
      bool allWeaponsExist = WM_CheckCVarWeaponsExisting(playerN);
      if (sameClass && allWeaponsExist)
      {
        WM_LoadDataFromCVars(playerN);
      }
    }
  }
}

function str WM_Unwrap(str wrappedString)
{
  int length = StrLen(wrappedString);
  str unwrapped = StrMid(wrappedString, 1, length - 2);
  return unwrapped;
}

function str WM_Wrap(str unwrappedString)
{
  str wrapped = StrParam(s:"\"", s:unwrappedString, s:"\"");
  return wrapped;
}

function void WM_LoadDataFromCVars(int playerN)
{
  for (int i = 0; i < weaponCounts[currentSet]; ++i)
  {
    str weaponClassVarName = StrParam(s:"M8fWeaponMenuWeaponClass", i:i);
    str weaponNameVarName  = StrParam(s:"M8fWeaponMenuWeaponName",  i:i);
    str weaponSlotVarName  = StrParam(s:"M8fWeaponMenuWeaponSlot",  i:i);

    names[currentSet][i] = WM_Unwrap(GetUserCVarString(playerN, weaponClassVarName));
    tags [currentSet][i] = WM_Unwrap(GetUserCVarString(playerN, weaponNameVarName));
    slots[currentSet][i] = GetUserCVar(playerN, weaponSlotVarName);
  }
}

function bool WM_CheckCVarWeaponsExisting(int playerN)
{
  for (int i = 0; i < weaponCounts[currentSet]; ++i)
  {
    str weaponClassCVar = StrParam(s:"M8fWeaponMenuWeaponClass", i:i);
    str weaponClass     = WM_Unwrap(GetUserCVarString(playerN, weaponClassCVar));
    if (!CheckClass(weaponClass)) { return false; }
  }
  return true;
}

function bool WM_IsHiddenWeapon(int wNumber)
{
  switch (currentSet)
  {

  case SET_VANILLA:        return (wNumber == 3 && isDoom1);
  case SET_FREEDOOM:       return (wNumber == 3 && isFreedoom1);
  case SET_PERK:           return (wNumber == 2); // Smooth Doom Rifle
  case SET_CHEX_QUEST:     return (wNumber == 3); // Super Large Zorcher is deathmatch-only
  case SET_PARKOUR:        return (wNumber == 2 || wNumber == 10 || wNumber == 11);
  case SET_BRUTAL_DOOM:    return (wNumber == 3 || wNumber == 9);
  case SET_ACCESSORIES:    return (wNumber == 2 || wNumber == 3);
  case SET_DOOMRL_ARSENAL: return true;

  case SET_HIGH_NOON_DRIFTER:
    if (wNumber == 10) return true; // Double whips
    // Single SMG when Second SMG is acquired:
    if (wNumber ==  6 && WM_IsInInventory(5)) return true;
    if (wNumber ==  5) return true; // Double SMG
    return false;

  case SET_X_WEAPON:
    if (wNumber == 27 || wNumber == 28) return true;
    if (wNumber ==  4 && WM_IsInInventory( 2)) return true;
    if (wNumber ==  8 && WM_IsInInventory( 7)) return true;
    if (wNumber == 11 && WM_IsInInventory(10)) return true;
    if (wNumber == 14 && WM_IsInInventory(13)) return true;
    if (wNumber == 17 && WM_IsInInventory(16)) return true;
    if (wNumber == 20 && WM_IsInInventory(19)) return true;
    if (wNumber == 24 && WM_IsInInventory(23)) return true;
    if (wNumber ==  2) return true;
    if (wNumber ==  3) return true;
    if (wNumber ==  7) return true;
    if (wNumber == 10) return true;
    if (wNumber == 13) return true;
    if (wNumber == 16) return true;
    if (wNumber == 19) return true;
    if (wNumber == 22) return true;
    return false;

  case SET_DOOM_DELTA: return (wNumber == 8);

  case SET_FACTOTUM:
    if (wNumber == 1 && WM_IsInInventory(2)) return true;
    if (wNumber == 5 && WM_IsInInventory(6)) return true;
    if (wNumber == 2) return true;
    if (wNumber == 6) return true;
    return false;

  case SET_FLAKES_DOOM: return true; // TODO: make game detection and hide weapons properly

  }

  return false;
}


// Weapon data access functions ////////////////////////////////////////////////

function int WM_GetWeaponSlot(int weaponNumber)
{
  return slots[currentSet][weaponNumber];
}

function str WM_GetWeaponName(int weaponNumber)
{
  return names[currentSet][weaponNumber];
}

function str WM_GetPrintableWeaponName(int weaponNumber)
{
  return tags[currentSet][weaponNumber];
}

function str WM_GetWeaponTag(int weaponNumber)
{
  return tags[currentSet][weaponNumber];
}

// Returns weaponNumber of next weapon in this slot, or -1 if there is no more
// weapons in this slot.
function int WM_GetWeaponSibling(int weaponNumber, bool doCycle, int playerN)
{
  int thisWeaponSlot = WM_GetWeaponSlot(weaponNumber);

  for (int i = 0; i < weaponCount; ++i)
  {
    int w = (weaponNumber + i) % weaponCount;
    if (w != weaponNumber
        && WM_GetWeaponSlot(w) == thisWeaponSlot
        && !WM_SkipNoAmmo(w, playerN))
    {
      int cycle = GetUserCVar(playerN, "m8fWmCycle");
      if (!doCycle && w < weaponNumber && cycle != 1) { return -1; }
      return w;
    }
  }

  return ERROR_NOT_FOUND;
}

function int WM_GetWeaponBySlotInInv(int slotNumber, int playerN)
{
  for (int i = 0; i < weaponCount; ++i)
  {
    if (slotNumber == WM_GetWeaponSlot(i))
      if (CheckInventory(WM_GetWeaponName(i)))
        if (!WM_SkipNoAmmo(i, playerN))
    {
      return i;
    }
  }

  return ERROR_NOT_FOUND;
}

function bool WM_IsOnlyInSlot(int weaponNumber)
{
  int slot = WM_GetWeaponSlot(weaponNumber);

  for (int prev = weaponNumber - 1; prev >= 0; --prev)
  {
    if (WM_GetWeaponSlot(prev) == slot)
      if (CheckInventory(WM_GetWeaponName(prev)))
        { return false; }
  }

  for (int next = weaponNumber + 1; next < weaponCount; ++next)
  {
    if (WM_GetWeaponSlot(next) == slot)
      if (CheckInventory(WM_GetWeaponName(next)))
        { return false; }
  }

  return true;
}

// Printing Weapons Menu functions /////////////////////////////////////////////

function void WM_UpdateMenu(int playerN)
{
  WM_ClearScreen();
  if (IsVisible()) { WM_PrintMenu(playerN); }
}

function void WM_ClearScreen(void)
{
  int id  = msgIdWeapon;
  int end = msgIdWeapon;
  if (nInventoryItems > weaponCount) { end += nInventoryItems; }
  else                               { end += weaponCount;     }

  do // when menu is disabled, weapon count is 0, so always clear first message.
  {
    HudMessage(s:""; msgFlags, id, 0, 0, 0, 0);
    ++id;
  } while (id < end);

  // clear slots numbers
  end = msgIdWeapon + MAX_WEAPONS_NUMBER + weaponCount;
  for (id = msgIdWeapon + MAX_WEAPONS_NUMBER; id < end; ++id)
  {
    HudMessage(s:""; msgFlags, id, 0, 0, 0, 0);
  }

  HudMessage(s:""; msgFlags, msgIdSelected,    0, 0, 0, 0);
  HudMessage(s:""; msgFlags, msgIdHighlighted, 0, 0, 0, 0);
  HudMessage(s:""; msgFlags, msgIdIcon,        0, 0, 0, 0);
  HudMessage(s:""; msgFlags, msgIdBackground,  0, 0, 0, 0);
  HudMessage(s:""; msgFlags, msgIdBackgroundA, 0, 0, 0, 0);
  HudMessage(s:""; msgFlags, msgIdBackgroundB, 0, 0, 0, 0);
}

function void WM_MaybeShowBackground(int backgroundMode, int playerN)
{
  bool showBackground = GetUserCVar(playerN, "m8f_wm_ShowBackground");

  if (!showBackground) { return; }

  switch (backgroundMode)
  {
  case BACKGROUND_LEFT:
    SetFont("wmbgleft");
    SetHudSize(600, 1, true);
    HudMessage(s:"A"; msgFlags, msgIdBackground,  0, 0.0, -1.0, 0);
    HudMessage(s:"A"; msgFlags, msgIdBackgroundA, 0, 0.0,  0.0, 0);
    HudMessage(s:"A"; msgFlags, msgIdBackgroundB, 0, 0.0,  1.0, 0);
    break;

  case BACKGROUND_TOP:
    SetFont("wmbgtop");
    SetHudSize(1, 600, true);
    HudMessage(s:"A"; msgFlags, msgIdBackground,  0, -1.0, 100.0, 0);
    HudMessage(s:"A"; msgFlags, msgIdBackgroundA, 0,  0.0, 100.0, 0);
    HudMessage(s:"A"; msgFlags, msgIdBackgroundB, 0,  1.0, 100.0, 0);
    break;

  case BACKGROUND_RIGHT:
    SetFont("wmbgrght");
    SetHudSize(600, 1, true);
    HudMessage(s:"A"; msgFlags, msgIdBackground,  0, 600.0, -1.0, 0);
    HudMessage(s:"A"; msgFlags, msgIdBackgroundA, 0, 600.0,  0.0, 0);
    HudMessage(s:"A"; msgFlags, msgIdBackgroundB, 0, 600.0,  1.0, 0);
    break;
  }

  SetHudSize(0, 0, true);
}

function void WM_PrintMenu(int playerN)
{
  int availableWeaponColor    = GetUserCVar(playerN, "M8FAvailableWeaponColor");
  int notAvailableWeaponColor = GetUserCVar(playerN, "M8FNotAvailableWeaponColor");
  int highlightedWeaponColor  = GetUserCVar(playerN, "M8FHighlightedWeaponColor");
  int selectedWeaponColor     = GetUserCVar(playerN, "M8FSelectedWeaponColor");
  int noAmmoColor             = GetUserCVar(playerN, "m8f_wm_NoAmmoColor");

  bool showNotAvailable = GetUserCVar(playerN, "M8FShowNotAvailable");
  bool doubleSpaceSlots = GetUserCVar(playerN, "m8f_wm_DoubleSpaceBetweenSlots");
  bool highToLow      = GetUserCVar(playerN, "M8FWeaponMenuHighToLow");
  int  ammoMode       = GetUserCVar(playerN, "M8fWeaponMenuShowAmmoCounts");
  int  displayMode    = GetUserCVar(playerN, "m8f_wm_DisplayMode");
  int  y              = GetUserCVar(playerN, "M8FWeaponMenuYStart");
  int  yStart = y;
  int  stepMultiplier = GetUserCVar(playerN, "M8FWeaponMenuStepMultiplier");
  int  stepMultiplied = (step * stepMultiplier) >> 16;

  bool showTags;
  bool slotOnLeft;
  bool withSlot;
  int  x;
  int  xStep;
  int  yStep;
  int  itemCount = 0; // used only in 6 and 9
  int  iconX;
  int  backgroundMode;

  if (displayMode == 6 || displayMode == 9) // dry run to count items
  {
    for (int i = 0; i < weaponCount; ++i)
    {
      if (!WM_IsInInventory(i))
      {
        if (!showNotAvailable)    { continue; }
        if (WM_IsHiddenWeapon(i)) { continue; }
      }
      ++itemCount;
    }
  }

  switch (displayMode)
  {
  case 0:
    x              = 0.0;
    xStep          = 0.0;
    yStep          = stepMultiplied;
    showTags       = true;
    slotOnLeft     = true;
    withSlot       = false;
    iconX          = 0.08;
    backgroundMode = BACKGROUND_LEFT;
    break;

  case 1:
    x              = 0.0;
    xStep          = 0.0;
    yStep          = stepMultiplied;
    showTags       = false;
    slotOnLeft     = true;
    withSlot       = false;
    iconX          = 0.08;
    backgroundMode = BACKGROUND_LEFT;
    break;

  case 2:
    x              = 0.0;
    xStep          = stepMultiplied;
    yStep          = 0.0;
    showTags       = false;
    slotOnLeft     = true;
    withSlot       = false;
    iconX          = 0.08;
    backgroundMode = BACKGROUND_TOP;
    break;

  case 3:
    x              = 0.5;
    xStep          = 0.0;
    yStep          = stepMultiplied;
    showTags       = true;
    slotOnLeft     = true;
    withSlot       = true;
    iconX          = -0.5;
    backgroundMode = BACKGROUND_TOP;
    break;

  case 4:
    x              = 0.5;
    xStep          = 0.0;
    yStep          = stepMultiplied;
    showTags       = true;
    slotOnLeft     = false;
    withSlot       = true;
    iconX          = -0.5;
    backgroundMode = BACKGROUND_TOP;
    break;

  case 5:
    x              = 0.5;
    xStep          = 0.0;
    yStep          = stepMultiplied;
    showTags       = false;
    slotOnLeft     = true;
    withSlot       = false;
    iconX          = -0.5;
    backgroundMode = BACKGROUND_TOP;
    break;

  case 6:
    x              = 0.5 -
                     ((itemCount - 1 + WM_CountDuplicateSlots(showNotAvailable, doubleSpaceSlots))
                     * stepMultiplied) / 2;
    xStep          = stepMultiplied;
    yStep          = 0.0;
    showTags       = false;
    slotOnLeft     = true;
    withSlot       = false;
    iconX          = -0.5;
    backgroundMode = BACKGROUND_TOP;
    break;

  case 7:
    x              = 1.0;
    xStep          = 0.0;
    yStep          = stepMultiplied;
    showTags       = true;
    slotOnLeft     = false;
    withSlot       = false;
    iconX          = -0.92;
    backgroundMode = BACKGROUND_RIGHT;
    break;

  case 8:
    x              = 1.0;
    xStep          = 0.0;
    yStep          = stepMultiplied;
    showTags       = false;
    slotOnLeft     = false;
    withSlot       = false;
    iconX          = -0.92;
    backgroundMode = BACKGROUND_RIGHT;
    break;

  case 9:
    x              = 1.0;
    highToLow      = !highToLow;
    xStep          = -stepMultiplied;
    yStep          = 0.0;
    showTags       = false;
    slotOnLeft     = false;
    withSlot       = false;
    iconX          = -0.92;
    backgroundMode = BACKGROUND_TOP;
    break;
  }

  WM_MaybeShowBackground(backgroundMode, playerN);
  WM_SetupFont(playerN);

  if (!showTags) // print weapon info on center
  {
    int infoX = 0.5;
    switch (displayMode)
    {
    case 1: infoX = -0.04; break;
    case 2: infoX =  0.0;  break;
    case 5: infoX = -0.52; break;
    case 8: infoX =  0.96; break;
    case 9: infoX =  1.0;  break;
    }

    str ammo;
    if (selectedWeapon != WEAPON_HOLSTERED
        && selectedWeapon != highlightedWeapon
        && selectedWeapon != ERROR_NOT_FOUND)
    {
      str message = WM_GetPrintableWeaponName(selectedWeapon);
      if (ammoMode != 0)
      {
        str selectedClass = WM_GetWeaponName(selectedWeapon);
        ammo = WM_GetAmmoString(selectedClass, ammoMode, playerN);
        if (StrLen(ammo) != 0)
        {
          message = StrParam(s:message, s:" - ", s:ammo);
        }
      }
      HudMessage(s:" ", s:message, s:" ";
                 msgFlags, msgIdSelected,
                 selectedWeaponColor, infoX, y + stepMultiplied * 4, 0);
    }

    str highlightedName = WM_GetPrintableWeaponName(highlightedWeapon);
    message = highlightedName;

    if (ammoMode != 0)
    {
      str highlightedClass = WM_GetWeaponName(highlightedWeapon);
      ammo = WM_GetAmmoString(highlightedClass, ammoMode, playerN);
      if (StrLen(ammo) != 0)
      {
        message = StrParam(s:message, s:" - ", s:ammo);
      }
    }
    HudMessage(s:" ", s:message, s:" ";
               msgFlags, msgIdHighlighted,
               highlightedWeaponColor, infoX, y + stepMultiplied * 2, 0);

  }
  else
  {
    HudMessage(s:""; msgFlags, msgIdSelected,    0, 0, 0, 0);
    HudMessage(s:""; msgFlags, msgIdHighlighted, 0, 0, 0, 0);
  }

  int iBegin;
  int iEnd;
  int iStep;
  if (highToLow) { iBegin = weaponCount - 1; iEnd = -1;          iStep = -1; }
  else           { iBegin = 0;               iEnd = weaponCount; iStep =  1; }

  int prevSlot = -1;

  for (i = iBegin; i != iEnd; i += iStep)
  {
    if (!WM_IsInInventory(i))
    {
      if (!showNotAvailable)    { continue; }
      if (WM_IsHiddenWeapon(i)) { continue; }
    }

    if (doubleSpaceSlots)
    {
      int currentSlot = WM_GetWeaponSlot(i);
      bool otherSlot = (prevSlot != -1 && currentSlot != prevSlot);
      if (otherSlot)
      {
        x += xStep;
        y += yStep;
      }
      prevSlot = currentSlot;
    }

    int color;
    if      (i == highlightedWeapon) { color = highlightedWeaponColor; }
    else if (i == selectedWeapon)
    {
      if (!WM_HasAmmo(WM_GetWeaponName(i), playerN)) { color = noAmmoColor; }
      else { color = selectedWeaponColor; }
    }
    else if (WM_IsInInventory(i))
    {
      if (!WM_HasAmmo(WM_GetWeaponName(i), playerN)) { color = noAmmoColor; }
      else { color = availableWeaponColor; }
    }
    else { color = notAvailableWeaponColor; }

    WM_PrintHudWeapon(i, color, x, y, slotOnLeft, withSlot, showTags, ammoMode, playerN);

    x += xStep;
    y += yStep;
  }

  int showIcons = GetUserCVar(playerN, "m8f_wm_ShowIcons");
  if (showIcons)
  {
    str weaponClass = WM_GetWeaponName(highlightedWeapon);
    if (currentSet == SET_REKKR) { weaponClass = StrParam(s:weaponClass, s:"_rekkr"); }
    ScriptCall("WMZscriptHelper", "GetWeaponIcon", weaponClass);
    str icon = GetUserCVarString(playerN, "m8f_wm_ResultString");
    if (StrLen(icon) > 0)
    {
      int iconY = -(yStart - stepMultiplied * 2);
      SetFont(icon);
      HudMessage(s:"A";
                 msgFlags, msgIdIcon,
                 highlightedWeaponColor, iconX, iconY, 0);
      WM_SetupFont(playerN);
    }
  }
}

function bool WM_HasAmmo(str weaponClass, int playerN)
{
  ScriptCall("WMZScriptHelper", "HasAmmo", weaponClass);
  bool hasAmmo = GetUserCVar(playerN, "m8f_wm_ResultInt");
  return hasAmmo;
}

function int WM_CountDuplicateSlots(bool showNotAvailable, bool doubleSpaceSlots)
{
  if (!doubleSpaceSlots) { return 0; }

  int count = 0;
  int prevSlot = -1;

  for (int i = 0; i < weaponCount; ++i)
  {
    if (!WM_IsInInventory(i))
    {
      if (!showNotAvailable)    { continue; }
      if (WM_IsHiddenWeapon(i)) { continue; }
    }

    int currentSlot = WM_GetWeaponSlot(i);
    bool otherSlot = (prevSlot != -1 && currentSlot != prevSlot);
    if (otherSlot)
    {
      ++count;
    }
    prevSlot = currentSlot;
  }

  return count;
}

function str WM_MakeWeaponString( int  weaponNumber
                                , bool withSlot
                                , bool slotOnLeft
                                , int  ammoMode
                                , int  playerN
                                )
{
  str result = WM_GetWeaponTag(weaponNumber);

  if (withSlot)
  {
    int slot = WM_GetWeaponSlot(weaponNumber);
    if (slotOnLeft) { result = StrParam(d:slot,   s:" ", s:result); }
    else            { result = StrParam(s:result, s:" ", d:slot  ); }
  }
  else // no slot, just space
  {
    if (slotOnLeft) { result = StrParam(s:"    ", s:result); }
    else            { result = StrParam(s:result, s:"    "); }
  }

  if (ammoMode)
  {
    str ammo = WM_GetAmmoString(WM_GetWeaponName(weaponNumber), ammoMode, playerN);
    if (StrLen(ammo) != 0)
    {
      if (slotOnLeft) { result = StrParam(s:result, s:" - ", s:ammo  ); }
      else            { result = StrParam(s:ammo,   s:" - ", s:result); }
    }
  }

  return result;
}

function void WM_PrintHudWeapon( int  weaponNumber
                               , int  color
                               , int  x
                               , int  y
                               , bool slotOnLeft
                               , bool withSlot
                               , bool showTags
                               , int  ammoMode
                               , int  playerN
                               )
{
  int id = msgIdWeapon + weaponNumber;

  if (!withSlot)
  {
    int slotNumber = WM_GetWeaponSlot(weaponNumber);
    HudMessage(s:" ", i:slotNumber, s:" ";
               msgFlags, id + MAX_WEAPONS_NUMBER, color, x, y, 0);
  }

  if (!showTags) { return; }

  str weaponString = WM_MakeWeaponString(weaponNumber, withSlot, slotOnLeft, ammoMode, playerN);

  HudMessage(s:" ", s:weaponString, s:" "; msgFlags, id, color, x, y, 0);
}

function void WM_SetupFont(int playerN)
{
  str font    = GetUserCVarString(playerN, "m8f_wm_font");
  SetFont(font);
}


// Control functions section ///////////////////////////////////////////////////

function int WM_FindRealSelectedWeapon(void)
{
  return WM_FindInWeaponList(GetWeapon());
}

function int WM_FindInWeaponList(str weaponName)
{
  for (int i = 0; i < weaponCount; ++i)
  {
    if (StrICmp(weaponName, WM_GetWeaponName(i)) == 0)
    {
      return i;
    }
  }
  return ERROR_NOT_FOUND;
}

function void WM_Unholster(int playerN)
{
  int holsterSpeedMultiplier = GetUserCvar(playerN, "M8fWeaponMenuHolsterSpeedMultiplier");
  if (holsterSpeedMultiplier != 0.0)
  {
    SetActorProperty(0, APROP_SPEED, 1.0);
  }

  bool fovChangeEnabled = GetUserCvar(playerN, "m8f_wm_HolsterFovEnabled");
  if (fovChangeEnabled)
  {
    ScriptCall("WMZScriptHelper", "SetFov", originalFov);
  }
}

function void WM_SelectWeapon(int weaponNumber, bool changeLast, int playerN)
{
  if (weaponNumber == selectedWeapon || weaponNumber == -1) { return; }
  if (WM_IsZoomed()) { WM_ToggleZoom(playerN); }

  str  weaponName = WM_GetWeaponName(weaponNumber);
  bool success    = SetWeapon(weaponName);

  if (success)
  {
    if (selectedWeapon == WEAPON_HOLSTERED)
    {
      WM_Unholster(playerN);
    }
    else if (changeLast)
    {
      WM_SetLastUsedWeapon(WM_GetWeaponName(selectedWeapon), playerN);
    }

    WM_SetSelectedWeapon(weaponNumber, playerN);

    WM_MaybePlaySoundOnWeaponChange(playerN);
  }
  else
  {
    str printableWeaponName = WM_GetPrintableWeaponName(weaponNumber);
    HudMessage(s:printableWeaponName, s:": no ammo.";
               msgFlags, msgIdAmmo, CR_RED, 0.5, 0.5, 1.0);

    WM_SetHighlightedWeapon(selectedWeapon, playerN);
  }
}

function void WM_MaybePlaySoundOnWeaponChange(int playerN)
{
  bool playSoundOnWeaponChange = GetUserCVar(playerN, "m8f_wm_PlaySoundOnWeaponChange");
  if (playSoundOnWeaponChange)
  {
    WM_PlaySwitchSound(playerN);
  }
}

function void WM_InitApiCvars(int playerN)
{
  SetUserCVar(playerN, "M8fWeaponMenuWeaponCount", weaponCount);
  SetUserCVar(playerN, "M8fWeaponMenuIsOpened", false);

  SetUserCVar      (playerN, "m8f_wm_PreviousWeaponSet",   currentSet);
  SetUserCVarString(playerN, "m8f_wm_PreviousPlayerClass", GetActorClass(0));

  for (int i = 0; i < weaponCount; ++i) {
    str weaponClassVarName = StrParam(s:"M8fWeaponMenuWeaponClass", i:i);
    str weaponNameVarName  = StrParam(s:"M8fWeaponMenuWeaponName",  i:i);
    str weaponSlotVarName  = StrParam(s:"M8fWeaponMenuWeaponSlot",  i:i);

    SetUserCVarString(playerN, weaponClassVarName, WM_Wrap(WM_GetWeaponName(i)));
    SetUserCVarString(playerN, weaponNameVarName,  WM_Wrap(WM_GetPrintableWeaponName(i)));
    SetUserCVar      (playerN, weaponSlotVarName,  WM_GetWeaponSlot(i));
  }
}

function void WM_PlaySwitchSound(int playerN)
{
  str switchSound = GetUserCVarString(playerN, "m8f_wm_SwitchSound");
  PlaySound(0, switchSound);
}

function void WM_SetupAddons(int playerN)
{
  if (currentSet == SET_FALLBACK) { return; }

  WM_MaybeTacticalChainsaw(playerN);
  WM_MaybeUACSurvivalPack();
}

function void WM_AddWeapon(int slot, str class, str name)
{
  slots[currentSet][weaponCount] = slot;
  names[currentSet][weaponCount] = class;
  tags [currentSet][weaponCount] = name;
  ++weaponCounts[currentSet];
  ++weaponCount;
}

function void WM_MaybeUACSurvivalPack(void)
{
  str satchelChargeClass = "Det_satchelCharge";
  if (CheckClass(satchelChargeClass))
  {
    WM_AddWeapon(0, satchelChargeClass, "Satchel Charge with Detonator");
  }

  str pipebombClass = "Det_Pipebomb";
  if (CheckClass(pipebombClass))
  {
    WM_AddWeapon(0, pipebombClass, "Pipebombs with Detonator");
  }
}

function void WM_MaybeTacticalChainsaw(int playerN)
{
  // function specifically for Tactical Chainsaw mod
  // https://www.doomworld.com/idgames/combos/ph_stuff

  str tacticalClass = "TacticalChainsaw";
  if (!CheckClass(tacticalClass)) { return; }

  for (int i = weaponCount; i > 0; --i)
  {
    WM_SwapWeapons(i, i-1, true, playerN);
  }
  slots[currentSet][0] = 1;
  names[currentSet][0] = tacticalClass;
  tags [currentSet][0] = "Tactical Chainsaw";
  ++weaponCounts[currentSet];
  ++weaponCount;
}

#define N_MATCHED_CLASSES 19

function int WM_SpecialMatchClassToWeaponSet(str class)
{
  // First case: one weapon set for several classes.

  str classes[N_MATCHED_CLASSES][2] =
  {
    { "DoomRLMarine"        , SET_DOOMRL_ARSENAL },
    { "DoomRLScout"         , SET_DOOMRL_ARSENAL },
    { "DoomRLTechnician"    , SET_DOOMRL_ARSENAL },
    { "DoomRLRenegade"      , SET_DOOMRL_ARSENAL },
    { "DoomRLDemolitionist" , SET_DOOMRL_ARSENAL },
    { "DoomRLCommando"      , SET_DOOMRL_ARSENAL },

    { "XDoomPlayer"         , SET_X_WEAPON       },
    { "XDoomPlayer2"        , SET_X_WEAPON       },
    { "XDoomPlayer3"        , SET_X_WEAPON       },
    { "XDoomPlayer4"        , SET_X_WEAPON       },

    { "HarmonyPlayer"       , SET_HARMONY        },

    { "LoreleiPlayer"       , SET_DOOM_DELTA     },
    { "JohnPlayer"          , SET_DOOM_DELTA     },
    { "DimitriPlayer"       , SET_DOOM_DELTA     },
    { "ThiPlayer"           , SET_DOOM_DELTA     },
    { "BetaPlayer"          , SET_DOOM_DELTA     },

    { "BDoomer"             , SET_BRUTAL_DOOM    },
    { "Doomer2"             , SET_BRUTAL_DOOM    },
    { "TacticalDoomer"      , SET_BRUTAL_DOOM    },
  };

  for (int i = 0; i < N_MATCHED_CLASSES; ++i)
  {
    if (StrCmp(class, classes[i][0]) == 0)
    {
      return classes[i][1];
    }
  }

  // Second case: one class for several weapon sets.

  if (StrCmp(class, "DoomPlayer") == 0)
  {
    if      (WM_IsRekkr())    { return SET_REKKR;     }
    else if (WM_IsHarmony())  { return SET_HARMONY;   }
    else if (WM_IsAbortM())   { return SET_ABORT_M;   }
    else if (WM_IsCyanDoom()) { return SET_CYAN_DOOM; }
    else if (WM_IsFreedoom1() || WM_IsFreedoom2()) { return SET_FREEDOOM; }
    else                      { return SET_VANILLA;   }
  }

  if (StrCmp(class, "PerkDPlayer") == 0)
  {
    if (WM_IsEVP())     { return SET_EVP;     }
    if (WM_IsVSmooth()) { return SET_VSMOOTH; }
    else                { return SET_PERK;    }
  }

  if (StrCmp(class, "FKPlayer") == 0)
  {
    if (WM_IsFlakesDoom()) { return SET_FLAKES_DOOM; }
    else                   { return SET_KRIEGSLAND;  }
  }

  return ERROR_NOT_FOUND;
}

function int WM_GetWeaponSet(int playerN)
{
  bool forceFallbackMode = GetUserCVar(playerN, "m8f_wm_ForceFallbackMode");
  if (forceFallbackMode) { return SET_FALLBACK; }

  str currentClass = GetActorClass(0);

  // search for class in special lists (class/set: one-to-many and many-to-one).
  int matchedClass = WM_SpecialMatchClassToWeaponSet(currentClass);
  if (matchedClass != ERROR_NOT_FOUND)
  {
    return matchedClass;
  }

  // search for class in regular lists (class/set: one-to-one).
  for (int c = 0; c < SETS_NUMBER; ++c)
  {
    if (CheckActorClass(0, playerClassNames[c]))
    {
      return c;
    }
  }

  return SET_FALLBACK;
}

function bool WM_IsTitlemap(void)
{
  str mapLumpName = StrParam(n:PRINTNAME_LEVEL);
  return (StrICmp(mapLumpName, "TITLEMAP") == 0);
}

function bool WM_IsOpenOnScroll(int playerN)
{
  return GetUserCVar(playerN, "M8fWeaponMenuOpenOnScroll");
}

function bool WM_IsMelee(int playerN)
{
  if (selectedWeapon == WEAPON_HOLSTERED) return true;
  if (WM_GetWeaponSlot(selectedWeapon) != 1) return false;

  int isSlot1Melee = !GetUserCVar(playerN, "m8f_wm_IsNotSlot1Melee");

  return isSlot1Melee;
}

// Scripts section /////////////////////////////////////////////////////////////

script "ShowWeaponMenu" ENTER
{
  int playerN = PlayerNumber();
  int state   = WM_GetInitialState(playerN);

  if (state == STATE_TERMINATED) { terminate; }

  // for some reason without delay only vanilla weapons will be listed.
  if (currentSet == SET_FALLBACK) { Delay(1); }

  WM_ChangeState(state, playerN);

  int updatePeriod     = 10;
  int updateCount      =  0;

  int keyRepeatPeriod  = 4;
  int keyRepeat        = 0;

  int oldInstant       = GetUserCVar(playerN, "M8fWeaponMenuInstantSwitch");

  int distanceCheckTid = UniqueTID();

  // options
  while (true)
  {
    // CVar may have been reset by other games while this game was saved.
    SetUserCVar(playerN, "M8fWeaponMenuIsEnabled", true);
    SetUserCVar(playerN, "M8fWeaponMenuIsOpened", IsOpened() || IsInventory());

    // emulating repeated key press
    if (keyRepeat < keyRepeatPeriod) { ++keyRepeat; }
    else
    {
      keyRepeat = 0;

      bool isSmartPressed = GetUserCVar(playerN, "m8f_wm_SmartPressed");
      if (isSmartPressed != -1)
      {
        bool cycle = GetUserCVar(playerN, "m8fwmCycle");
        SetUserCVar(playerN, "m8fWmCycle", cycle + 1);
        if (cycle > 1)
        {
          ACS_NamedExecute("SmartWeaponSelection", 0, isSmartPressed);
        }
      }
    }

    if (updateCount < updatePeriod) { ++updateCount; }
    else
    {
      updateCount = 0;

      bool instant = GetUserCVar(playerN, "M8fWeaponMenuInstantSwitch");
      if (oldInstant != instant)
      {
        WM_InstantSwitch(instant == 2);
        oldInstant = instant;
      }

      if (IsVisible())
      {
        bool updated  = WM_UpdateIsInInventory();
        int  ammoMode = GetUserCVar(playerN, "M8fWeaponMenuShowAmmoCounts");
        if (updated || ammoMode) { WM_UpdateMenu(playerN); }
      }

      if (IsInventory())
      {
        WM_PrintInventoryMenu(playerN);
      }
    }

    /* debug output
    SetFont("SMALLFONT");
    Log(s:"sel:",   i:selectedWeapon,
        s:" high:", i:highlightedWeapon,
        s:" last:", s:lastUsedWeapon);
    ///*///

    // Check if currently selected weapon corresponds to what player is holding.
    // Handles situation when player drops a weapon, or switches to new weapon
    // on pickup.
    if (selectedWatchEnabled && !WM_IsSelected(selectedWeapon))
    {
      str currentWeaponClass = GetWeapon();
      int currentWeaponI     = WM_FindInWeaponList(currentWeaponClass);

      if (currentWeaponI != ERROR_NOT_FOUND)
      {
        str selectedClass = WM_GetWeaponName(selectedWeapon);
        if (CheckInventory(selectedClass))
        {
          WM_SetLastUsedWeapon(selectedClass, playerN);
        }

        if (WM_IsZoomed()) { WM_ToggleZoomWeapon(selectedClass, playerN); }
        WM_SetHighlightedWeapon(currentWeaponI, playerN);
        WM_SetSelectedWeapon(highlightedWeapon, playerN);
        WM_UpdateMenu(playerN);
      }
    }

    Delay(1);
  }
}

script "ApplyWeaponMenuSettings" (void)
{
  if (IsUninitialized()) { terminate; }

  int playerN = PlayerNumber();
  WM_UpdateMenu(playerN);
}

script "OpenWeaponMenu" (void)
{
  if (IsOpened()) { terminate; }
  ACS_NamedExecute("ToggleWeaponMenu", 0, 0);
}

script "CloseWeaponMenu" (void)
{
  if (!IsOpened()) { terminate; }
  ACS_NamedExecute("ToggleWeaponMenu", 0, 0);
}

script "ToggleWeaponMenu" (int closeWithoutAction)
{
  if (IsUninitialized()) { terminate; }

  if (IsInventory())
  {
    int playerN = PlayerNumber();

    if (closeWithoutAction)
    {
      WM_ChangeState(STATE_CLOSED, playerN);
    }
    else
    {
      str selectedInventory = WM_GetSelectedInventory(playerN);
      if (StrCmp(selectedInventory, "wm_none") != 0)
      {
        UseInventory(selectedInventory);
        bool closeAfterUse = GetUserCVar(playerN, "m8f_wm_CloseInvMenuAfterUse");
        if (closeAfterUse) { WM_ChangeState(STATE_CLOSED, playerN); }
      }
      else
      {
        WM_ChangeState(STATE_CLOSED, playerN);
      }
    }
    terminate;
  }

  if (IsOpened() && closeWithoutAction)
  {
    WM_SetHighlightedWeapon(WM_FindRealSelectedWeapon(), playerN);
  }

  WM_ToggleWeaponMenu(playerN);
}

function void WM_ToggleWeaponMenu(int playerN)
{
  if (IsOpened())
  {
    WM_ChangeState(STATE_CLOSED, playerN);
  }
  else
  {
    WM_ChangeState(STATE_OPENED, playerN);
  }
}

function int WM_FindSelectedInventoryIndex(int playerN)
{
  // find currently selected
  str selectedInventoryClass = WM_GetSelectedInventory(playerN);
  for (int i = 0; i < nInventoryItems; ++i)
  {
    if (StrCmp(selectedInventoryClass, inventoryClasses[i]) == 0)
    {
      return i;
    }
  }
  return ERROR_NOT_FOUND;
}

function int WM_FindNextAvailableInventory(int selectedInventoryIndex)
{
  for (int i = 1; i < nInventoryItems; ++i)
  {
    int availableIndex = (selectedInventoryIndex + i) % nInventoryItems;
    if (CheckInventory(inventoryClasses[availableIndex]))
    {
      return availableIndex;
    }
  }
  return ERROR_NOT_FOUND;
}

function int WM_FindPrevAvailableInventory(int selectedInventoryIndex)
{
  for (int i = 1; i < nInventoryItems; ++i)
  {
    int availableIndex = (selectedInventoryIndex + nInventoryItems - i) % nInventoryItems;
    if (CheckInventory(inventoryClasses[availableIndex]))
    {
      return availableIndex;
    }
  }
  return ERROR_NOT_FOUND;
}

function void WM_SetSelectedInventory(int selectedIndex, int availableIndex, int playerN)
{
  if (selectedIndex == availableIndex || availableIndex == ERROR_NOT_FOUND) { return; }

  WM_PlaySwitchSound(playerN);
  str inventoryClass = inventoryClasses[availableIndex];
  ScriptCall("WMZscriptHelper", "SetSelectedInventory", inventoryClass);
}

function void WM_SelectNextInventory(int playerN)
{
  int selectedInventoryIndex = WM_FindSelectedInventoryIndex(playerN);
  if (selectedInventoryIndex == ERROR_NOT_FOUND) { return; }

  int nextAvailableInventoryIndex = WM_FindNextAvailableInventory(selectedInventoryIndex);
  WM_SetSelectedInventory(selectedInventoryIndex, nextAvailableInventoryIndex, playerN);
}

function void WM_SelectPreviousInventory(int playerN)
{
  int selectedInventoryIndex = WM_FindSelectedInventoryIndex(playerN);
  if (selectedInventoryIndex == ERROR_NOT_FOUND) { return; }

  int prevAvailableInventoryIndex = WM_FindPrevAvailableInventory(selectedInventoryIndex);
  WM_SetSelectedInventory(selectedInventoryIndex, prevAvailableInventoryIndex, playerN);
}

script "ScrollNextWeapon" (void)
{
  if (IsUninitialized()) { terminate; }

  int playerN = PlayerNumber();

  if (IsInventory())
  {
    WM_SelectNextInventory(playerN);
    WM_PrintInventoryMenu(playerN);
    terminate;
  }

  if (WM_IsOpenOnScroll(playerN) && !IsOpened())
  {
    WM_ChangeState(STATE_OPENED, playerN);
  }

  int start;
  int n;
  int i;

  if (IsOpened())
  {
    start = highlightedWeapon + 1;
    for (n = 0; n < weaponCount; ++n)
    {
      i = (start + n) % weaponCount;
      if (WM_IsInInventory(i) && !WM_SkipNoAmmo(i, playerN)) { break; }
    }

    WM_SetHighlightedWeapon(i, playerN);
    if (n != weaponCount - 1) { WM_PlaySwitchSound(playerN); }
  }

  else
  {
    if (WM_IsZoomed()) { WM_ToggleZoom(playerN); }

    if (selectedWeapon == WEAPON_HOLSTERED) { start = 0;                  }
    else                                    { start = selectedWeapon + 1; }

    for (n = 0; n < weaponCount; ++n)
    {
      i = (start + n) % weaponCount;
      if (SetWeapon(WM_GetWeaponName(i)) && !WM_SkipNoAmmo(i, playerN)) { break; }
    }

    if (n != weaponCount - 1)
    {
      WM_SetLastUsedWeapon(WM_GetWeaponName(selectedWeapon), playerN);
      WM_SetSelectedWeapon(i, playerN);
      WM_SetHighlightedWeapon(i, playerN);
      WM_MaybeDisplayNameTag();
      WM_MaybePlaySoundOnWeaponChange(playerN);
    }
  }

  WM_UpdateMenu(playerN);
}

function void WM_MaybeDisplayNameTag(void)
{
  bool showNameTag = (GetCVar("displaynametags") >= 2);
  if (showNameTag)
  {
    int nametagcolor = GetCVar("nametagcolor");
    str selectedName = WM_GetPrintableWeaponName(selectedWeapon);
    HudMessage(s:selectedName;
               HUDMSG_FADEOUT, msgIdTag, nametagcolor, 0.5, 0.9, 2.0, 1.0);

  }
}

script "ScrollPreviousWeapon" (void)
{
  if (IsUninitialized()) { terminate; }

  int playerN = PlayerNumber();

  if (IsInventory())
  {
    WM_SelectPreviousInventory(playerN);
    WM_PrintInventoryMenu(playerN);
    terminate;
  }

  if (WM_IsOpenOnScroll(playerN) && !IsOpened())
  {
    WM_ToggleWeaponMenu(playerN);
  }

  int start;
  int n;
  int i;

  if (IsOpened())
  {
    start = highlightedWeapon - 1;
    for (n = 0; n < weaponCount; ++n)
    {
      i = (start - n + weaponCount) % weaponCount;
      if (WM_IsInInventory(i) && !WM_SkipNoAmmo(i, playerN)) { break; }
    }

    WM_SetHighlightedWeapon(i, playerN);
    if (n != weaponCount - 1) { WM_PlaySwitchSound(playerN); }
  }

  else
  {
    if (WM_IsZoomed()) { WM_ToggleZoom(playerN); }

    if (selectedWeapon == WEAPON_HOLSTERED) { start = weaponCount    - 1; }
    else                                    { start = selectedWeapon - 1; }

    for (n = 0; n < weaponCount; ++n)
    {
      i = (start - n + weaponCount) % weaponCount;
      if (SetWeapon(WM_GetWeaponName(i)) && !WM_SkipNoAmmo(i, playerN)) { break; }
    }

    if (n != weaponCount - 1)
    {
      WM_SetLastUsedWeapon(WM_GetWeaponName(selectedWeapon), playerN);
      WM_SetSelectedWeapon(i, playerN);
      WM_SetHighlightedWeapon(i, playerN);
      WM_MaybeDisplayNameTag();
      WM_MaybePlaySoundOnWeaponChange(playerN);
    }
  }

  WM_UpdateMenu(playerN);
}

function bool WM_SkipNoAmmo(int weaponIndex, int playerN)
{
  bool shouldSkipNoAmmo = GetUserCvar(playerN, "m8f_wm_SkipNoAmmo");
  if (!shouldSkipNoAmmo) { return false; }

  bool hasAmmo = WM_HasAmmo(WM_GetWeaponName(weaponIndex), playerN);
  return !hasAmmo;
}

script "WM_NextWeaponInSlot" (void)
{
  int playerN = PlayerNumber();
  int sibling = WM_GetNextWeaponInSlot(selectedWeapon, true, playerN);

  if (sibling != -1 && sibling != selectedWeapon)
    {
      WM_SelectWeapon(sibling, true, playerN);
      WM_MaybeDisplayNameTag();
    }
}

function int WM_GetNextWeaponInSlot(int weaponIndex, bool cycle, int playerN)
{
  int i       = weaponIndex;
  int stopper = weaponCount;

  do
    {
      i = WM_GetWeaponSibling(i, cycle, playerN);
      if (i == -1) { break; }
      --stopper;
    }
  while (!WM_IsInInventory(i) && stopper);

  return i;
}

script "SmartWeaponSelection" (int slotNumber)
{
  if (IsUninitialized()) { terminate; }

  int playerN = PlayerNumber();

  if (IsInventory())
  {
    WM_ChangeState(STATE_CLOSED, playerN);
  }

  if (IsOpened())
  {
    int  currentSlot = WM_GetWeaponSlot(highlightedWeapon);
    bool sameSlot    = (slotNumber == currentSlot);
    if (sameSlot)
    {
      int sibling = WM_GetNextWeaponInSlot(highlightedWeapon, false, playerN);

      if (sibling != -1 && sibling != highlightedWeapon)
      {
        WM_SetHighlightedWeapon(sibling, playerN);
        WM_PlaySwitchSound(playerN);
      }
    }
    else
    {
      WM_HighlightFirstInInventory(slotNumber, playerN);
    }
  }

  else
  {
    bool immediatelySelect = GetUserCVar(playerN, "M8fWeaponMenuImmediatelySelectIfOnlyInSlot");
    if (immediatelySelect)
    {
      int weaponNumber = WM_GetWeaponBySlotInInv(slotNumber, playerN);
      if (weaponNumber == -1) { terminate; }

      if (WM_IsOnlyInSlot(weaponNumber))
      {
        if (CheckInventory(WM_GetWeaponName(weaponNumber)))
        {
          WM_SelectWeapon(weaponNumber, true, playerN);
          terminate;
        }
      }
    }

    WM_ToggleWeaponMenu(playerN);
    WM_HighlightFirstInInventory(slotNumber, playerN);
  }

  WM_UpdateMenu(playerN);
}

script "SelectLastUsedWeapon" (void)
{
  if (IsUninitialized()) { terminate; }

  int playerN = PlayerNumber();

  if (WM_CheckInventory(lastUsedWeapon))
  {
    WM_SelectWeapon(WM_FindInWeaponList(lastUsedWeapon), true, playerN);
  }

  WM_UpdateMenu(playerN);
}

script "WM_MarkWeaponAsFavorite" (void)
{
  if (IsUninitialized()) { terminate; }

  int playerN = PlayerNumber();

  if (selectedWeapon == WEAPON_HOLSTERED) { terminate; }
  SetUserCVar(playerN, "M8fWeaponMenuFavoriteWeapon", selectedWeapon);
  Log(s:WM_GetPrintableWeaponName(selectedWeapon), s:" is set as favorite weapon.");
}

script "WM_SelectFavoriteWeapon" (void)
{
  if (IsUninitialized()) { terminate; }

  int playerN = PlayerNumber();
  int favorite = GetUserCVar(playerN, "M8fWeaponMenuFavoriteWeapon");
  if (CheckInventory(WM_GetWeaponName(favorite)))
  {
    WM_SelectWeapon(favorite, true, playerN);
  }

  WM_UpdateMenu(playerN);
}


// Utility functions section ///////////////////////////////////////////////////

function bool WM_UpdateIsInInventory(void)
{
  bool updated = false;

  for (int i = 0; i < weaponCount; ++i)
  {
    bool old         = isInInventory[i];
    str  weaponClass = WM_GetWeaponName(i);

    if (CheckClass(weaponClass)) { isInInventory[i] = CheckInventory(weaponClass); }
    else                         { isInInventory[i] = false;                       }

    if (old != isInInventory[i]) { updated = true; }
  }

  return updated;
}

function void WM_ResetIsInInventory(void)
{
  for (int i = 0; i < weaponCount; ++i)
  {
    isInInventory[i] = CheckInventory(WM_GetWeaponName(i));
  }
}

function bool WM_IsInInventory(int weaponNumber)
{
  return isInInventory[weaponNumber];
}

function bool WM_IsSelected(int weaponNumber)
{
  if (weaponNumber == WEAPON_HOLSTERED) { return true; }
  return CheckWeapon(WM_GetWeaponName(weaponNumber));
}

function void WM_HighlightFirstInInventory(int slotNumber, int playerN)
{
  int weaponNumber = WM_GetWeaponBySlotInInv(slotNumber, playerN);
  if (WM_IsInInventory(weaponNumber) && highlightedWeapon != weaponNumber)
  {
    WM_SetHighlightedWeapon(weaponNumber, playerN);
    WM_PlaySwitchSound(playerN);
  }
}

function int WM_IfThenElse(bool condition, int trueValue, int falseValue)
{
  if (condition)
  {
    return trueValue;
  }

  return falseValue;
}

// Global variables write access functions /////////////////////////////////////

function void WM_SetHighlightedWeapon(int weaponNumber, int playerN)
{
  if (weaponNumber == WEAPON_HOLSTERED) { return; }
  highlightedWeapon = weaponNumber;
}

function void WM_SetSelectedWeapon(int weaponNumber, int playerN)
{
  selectedWeapon = weaponNumber;

  SetUserCVarString(playerN, "m8f_wm_SelectedWeaponTag",
                    WM_GetWeaponTag(selectedWeapon));
}

function void WM_SetLastUsedWeapon(str weaponClass, int playerN)
{
  lastUsedWeapon = weaponClass;

  SetUserCVarString(playerN, "m8f_wm_LastUsedWeapon", WM_Wrap(lastUsedWeapon));
}

// Weapon Priority Section /////////////////////////////////////////////////////

script "WM_ApplyTagChange" (void)
{
  int playerN           = PlayerNumber();
  str newName           = GetUserCVarString(playerN, "m8f_wm_SelectedWeaponTag");
  str weaponNameVarName = StrParam(s:"M8fWeaponMenuWeaponName", i:selectedWeapon);

  SetUserCVarString(playerN, weaponNameVarName, WM_Wrap(newName));
  tags[currentSet][selectedWeapon] = newName;
}

script "WM_IncreasePriority" (void)
{
  if (IsUninitialized()) { terminate; }

  str name = WM_GetPrintableWeaponName(highlightedWeapon);
  if (highlightedWeapon == 0)
  {
    Log(s:"Priority of ", s:name, s:" is already maximal.");
    terminate;
  }

  int oldMajorWeapon = highlightedWeapon - 1;
  int thisWeaponSlot = WM_GetWeaponSlot(highlightedWeapon);
  int oldWeaponSlot  = WM_GetWeaponSlot(oldMajorWeapon);
  if (thisWeaponSlot != oldWeaponSlot)
  {
    Log(s:"Priority of ", s:name, s:" is already maximal.");
    terminate;
  }

  int playerN = PlayerNumber();

  WM_SwapWeapons(highlightedWeapon, oldMajorWeapon, true, playerN);
  WM_SetHighlightedWeapon(oldMajorWeapon, playerN);
  Log(s:"Priority of ", s:name, s:" is increased.");
  WM_UpdateMenu(playerN);
}

function void WM_SwapWeapons(int w1, int w2, bool setCVars, int playerN)
{
  if (w1 == w2) { return; }

  int namesTmp = names[currentSet][w1];
  names[currentSet][w1] = names[currentSet][w2];
  names[currentSet][w2] = namesTmp;

  if (setCVars)
  {
    str weaponClassVarName1 = StrParam(s:"M8fWeaponMenuWeaponClass", i:w1);
    str weaponClassVarName2 = StrParam(s:"M8fWeaponMenuWeaponClass", i:w2);
    SetUserCVarString(playerN, weaponClassVarName1, WM_Wrap(WM_GetWeaponName(w1)));
    SetUserCVarString(playerN, weaponClassVarName2, WM_Wrap(WM_GetWeaponName(w2)));
  }

  int tagTmp = tags[currentSet][w1];
  tags[currentSet][w1] = tags[currentSet][w2];
  tags[currentSet][w2] = tagTmp;

  if (setCVars)
  {
    str weaponNameVarName1 = StrParam(s:"M8fWeaponMenuWeaponName", i:w1);
    str weaponNameVarName2 = StrParam(s:"M8fWeaponMenuWeaponName", i:w2);
    SetUserCVarString(playerN, weaponNameVarName1, WM_Wrap(WM_GetPrintableWeaponName(w1)));
    SetUserCVarString(playerN, weaponNameVarName2, WM_Wrap(WM_GetPrintableWeaponName(w2)));
  }

  int slotTmp = slots[currentSet][w1];
  slots[currentSet][w1] = slots[currentSet][w2];
  slots[currentSet][w2] = slotTmp;

  if (setCVars)
  {
    str slotVarName1 = StrParam(s:"M8fWeaponMenuWeaponSlot", i:w1);
    str slotVarName2 = StrParam(s:"M8fWeaponMenuWeaponSlot", i:w2);
    SetUserCVar(playerN, slotVarName1, WM_GetWeaponSlot(w1));
    SetUserCVar(playerN, slotVarName2, WM_GetWeaponSlot(w2));
  }

  int priorityTmp = priority[w1];
  priority[w1] = priority[w2];
  priority[w2] = priorityTmp;
}

script "WM_IncreaseSlot" (void)
{
  if (IsUninitialized()) { terminate; }

  int currentSlot = WM_GetWeaponSlot(highlightedWeapon);
  if (currentSlot == 11) { terminate; }

  int nextSlot[11] = { 10, 2, 3, 4, 5, 6, 7, 8, 9, 0, 11 };
  int targetSlot   = nextSlot[currentSlot];
  int playerN      = PlayerNumber();
  int i            = highlightedWeapon;

  if (i != weaponCount - 1)
  {
    while ((WM_GetWeaponSlot(i + 1) == currentSlot) && (i != weaponCount - 1))
    {
      WM_SwapWeapons(i, i + 1, true, playerN);
      if (i + 1 == selectedWeapon) { WM_SetSelectedWeapon(i, playerN); }
      ++i;
    }
  }
  WM_ResetIsInInventory();

  slots[currentSet][i] = targetSlot;
  str weaponSlotVarName = StrParam(s:"M8fWeaponMenuWeaponSlot",  i:i);
  SetUserCVar(playerN, weaponSlotVarName, targetSlot);

  WM_SetHighlightedWeapon(i, playerN);
  str name = WM_GetPrintableWeaponName(i);
  Log(s:"Slot of ", s:name, s:" is changed to ", i:targetSlot, s:".");
  WM_UpdateMenu(playerN);
}

script "WM_DecreaseSlot" (void)
{
  if (IsUninitialized()) { terminate; }

  int currentSlot = WM_GetWeaponSlot(highlightedWeapon);
  if (currentSlot == 1) { terminate; }

  int prevSlot[12] = { 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 10 };
  int targetSlot   = prevSlot[currentSlot];
  int playerN      = PlayerNumber();
  int i            = highlightedWeapon;

  if (i != 0)
  {
    while (WM_GetWeaponSlot(i - 1) == currentSlot && i != 0)
    {
      WM_SwapWeapons(i, i - 1, true, playerN);
      if (i - 1 == selectedWeapon) { WM_SetSelectedWeapon(i, playerN); }
      --i;
    }
  }
  WM_ResetIsInInventory();

  slots[currentSet][i] = targetSlot;
  str weaponSlotVarName = StrParam(s:"M8fWeaponMenuWeaponSlot",  i:i);
  SetUserCVar(playerN, weaponSlotVarName, targetSlot);

  str name = WM_GetPrintableWeaponName(highlightedWeapon);
  WM_SetHighlightedWeapon(i, playerN);
  Log(s:"Slot of ", s:name, s:" is changed to ", i:targetSlot, s:".");
  WM_UpdateMenu(playerN);
}

script "WM_PrintInfo" (void)
{
  Log(s:"Player: ", s:GetActorClass(0));
  Log(s:"Selected: ", i:selectedWeapon, s:": ",
      s:WM_GetWeaponName(selectedWeapon), s:": ",
      s:GetWeapon());
  Log(s:"Highlighted: ", i:highlightedWeapon, s:": ",
      s:WM_GetWeaponName(highlightedWeapon));
  Log(s:"Last used: ", s:lastUsedWeapon);
  int playerN = PlayerNumber();
  int favorite = GetUserCVar(playerN, "M8fWeaponMenuFavoriteWeapon");
  Log(s:"Favorite: ", i:favorite, s:": ",
      s:WM_GetWeaponName(favorite));
  Log(s:"Speed: ", f:GetActorProperty(0, APROP_Speed));
  Log(s:"State: ", i:globalState);

  if (currentSet == SET_FALLBACK) { Log(s:"Weapon Menu Plus - Universal Mode"); }
  else { Log(s:"Weapon Menu Plus - Extended Support Mode"); }
}

function str WM_GetAmmoString(str weaponClass, int ammoMode, int playerN)
{
  if (ammoMode == 0) { return ""; }

  bool showSecondary = ammoMode == 2;
  ScriptCall("WMZscriptHelper", "TellAmmo", weaponClass, showSecondary);
  return GetUserCVarString(playerN, "m8f_wm_ResultString");
}

function bool WM_IsWeaponReady(str weaponClass, int playerN)
{
  ScriptCall("WMZscriptHelper", "IsWeaponReady", weaponClass);
  bool isReady = GetUserCVar(playerN, "m8f_wm_ResultInt");
  return isReady;
}

function bool WM_IsWeaponDeselectable(str weaponClass, int playerN)
{
  ScriptCall("WMZscriptHelper", "IsWeaponDeselectable", weaponClass);
  bool isDeselectable = GetUserCVar(playerN, "m8f_wm_ResultInt");
  return isDeselectable;
}

function bool WM_CheckInventory(str weaponClass)
{
  if (!CheckClass    (weaponClass)) { return false; }
  if (!CheckInventory(weaponClass)) { return false; }
  return true;
}

bool returnToLast;
int returnTo;
bool wasZoomed;
bool favoriteFiring = false;

script "WM_FireFavoriteWeapon" (void)
{
  if (IsUninitialized()) { terminate; }

  if (selectedWeapon == WEAPON_HOLSTERED) { terminate; }

  // Cycle variable is used as a workaround for
  // https://forum.zdoom.org/viewtopic.php?t=61104
  int playerN = PlayerNumber();
  int cycleValue = GetUserCVar(playerN, "M8fWMCycle");
  int keyPressedMore = !((cycleValue <= 1) && (cycleValue != 0));
  if (keyPressedMore) { terminate; }

  int favorite = GetUserCVar(playerN, "M8fWeaponMenuFavoriteWeapon");
  str favoriteClass = WM_GetWeaponName(favorite);
  if (!CheckInventory(favoriteClass)) { terminate; }

  WM_MaybeToggleSlomoOnQuick(playerN);
  favoriteFiring = true;

  wasZoomed = WM_IsZoomed();
  returnToLast = (favorite != selectedWeapon);
  returnTo = selectedWeapon;
  selectedWatchEnabled = false;

  int fireMode = GetUserCVar(playerN, "m8f_wm_FavoriteFireMode");
  bool instant = (GetUserCVar(playerN, "M8fWeaponMenuInstantSwitch") == 1);
  if (instant) { WM_InstantSwitch(true); }
  WM_SelectWeapon(favorite, false, playerN);
  if (instant) { Delay(1); WM_InstantSwitch(false); }

  if (fireMode == 2) { Delay(10); } // No fire mode

  bool isReady = WM_IsWeaponReady(favoriteClass, playerN);
  int i = 0;
  int iMax = 35 * 2; // 2 seconds
  bool alreadyFired = false;
  while (!(WM_IsSelected(favorite) && isReady))
  {
    // this is to interrupt script in case something has gone wrong.
    if (i > 0 && isReady && !WM_IsSelected(favorite))
    {
      selectedWatchEnabled = true;
      terminate;
    }
    ++i;

    Delay(1);
    isReady = (WM_IsWeaponReady(favoriteClass, playerN) || i > iMax);

    if (alreadyFired == false)
    {
      int buttons = GetPlayerInput(-1, INPUT_BUTTONS);
      alreadyFired = (buttons & (BT_ATTACK|BT_ALTATTACK));
    }
  }

  if (alreadyFired) { Delay(1); }
  else
  {
    switch (fireMode)
    {
    case 0: ScriptCall("WMZScriptHelper", "FireWeapon",    favoriteClass); break;
    case 1: ScriptCall("WMZScriptHelper", "FireWeaponAlt", favoriteClass); break;
    case 2: break;
    }
  }

  favoriteFiring = false;
}

script "WM_FireFavoriteSwitchBack" (void)
{
  if (IsUninitialized()) { terminate; }

  while (favoriteFiring) { Delay(1); }

  int  playerN       = PlayerNumber();
  int  favorite      = GetUserCVar(playerN, "M8fWeaponMenuFavoriteWeapon");
  str  favoriteClass = WM_GetWeaponName(favorite);
  bool isReady       = WM_IsWeaponDeselectable(favoriteClass, playerN);

  while (!isReady)
  {
    Delay(1);
    isReady = WM_IsWeaponDeselectable(favoriteClass, playerN);
  }

  if (returnToLast && CheckInventory(WM_GetWeaponName(returnTo)))
  {
    bool instant = (GetUserCVar(playerN, "M8fWeaponMenuInstantSwitch") == 1);
    if (instant) { WM_InstantSwitch(true); }
    WM_SelectWeapon(returnTo, false, playerN);
    if (instant) { Delay(1); WM_InstantSwitch(false); }
    if (wasZoomed) { WM_ToggleZoom(playerN); }
  }

  selectedWatchEnabled = true;
}

function void WM_InstantSwitch(bool enable)
{
  SetPlayerProperty(0, enable, PROP_INSTANTWEAPONSWITCH);
}

#define N_MODS_NO_HOLSTER 1

script "WM_HolsterWeapon" (void)
{
  if (IsUninitialized()) { terminate; }

  int playerN = PlayerNumber();

  if (selectedWeapon == WEAPON_HOLSTERED) { terminate; }
  if (WM_IsZoomed()) { WM_ToggleZoom(playerN); }

  int forbiddenMods[N_MODS_NO_HOLSTER] =
  {
    SET_WEAPONS_OF_SATURN, // reason: A_Lower with 0 duration
  };
  for (int i = 0; i < N_MODS_NO_HOLSTER; ++i)
  {
    if (currentSet == forbiddenMods[i])
    {
      Log(s:"Weapon holstering is not supported in this mod.");
      terminate;
    }
  }

  int holsterSpeedMultiplier = GetUserCvar(playerN, "M8fWeaponMenuHolsterSpeedMultiplier");
  if (holsterSpeedMultiplier != 0.0)
  {
    SetActorProperty(0, APROP_SPEED, holsterSpeedMultiplier);
  }

  bool fovChangeEnabled = GetUserCvar(playerN, "m8f_wm_HolsterFovEnabled");
  if (fovChangeEnabled)
  {
    originalFov = WM_GetFov(playerN);
    int fovHolstered = GetUserCvar(playerN, "m8f_wm_HolsterFov");
    WM_SetFov(fovHolstered);
  }

  WM_ChangeState(STATE_CLOSED, playerN);
  WM_SetLastUsedWeapon(WM_GetWeaponName(selectedWeapon), playerN);
  WM_SetSelectedWeapon(WEAPON_HOLSTERED, playerN);
  ScriptCall("WMZScriptHelper", "HolsterWeapon");
}

function int WM_GetFov(int playerN)
{
  ScriptCall("WMZScriptHelper", "GetFov");
  return GetUserCVar(playerN, "m8f_wm_ResultInt") << 16;
}

function void WM_SetFov(int fov)
{
  ScriptCall("WMZScriptHelper", "SetFov", fov);
}

// Inventory menu section //////////////////////////////////////////////////////

script "WM_OpenInventoryMenu" (void)
{
  if (IsInventory()) { terminate; }
  ACS_NamedExecute("WM_InventoryMenu", 0);
}

script "WM_CloseInventoryMenu" (void)
{
  if (!IsInventory()) { terminate; }
  ACS_NamedExecute("WM_InventoryMenu", 0);
}

script "WM_InventoryMenu" (void)
{
  if (IsUninitialized()) { terminate; }

  int playerN = PlayerNumber();

  if (IsInventory())
  {
    WM_ChangeState(STATE_CLOSED, playerN);
  }
  else
  {
    if (nInventoryItems != 0)
    {
      WM_ChangeState(STATE_INVENTORY, playerN);
    }
    else
    {
      Log(s:"Inventory is empty.");
    }
  }
}

function void WM_FillInventoryItems(int playerN)
{
  ScriptCall("WMZScriptHelper", "GetInventoryList");

  str inventoryContents = GetUserCVarString(playerN, "m8f_wm_ResultString");

  int inventoryContentsLength = StrLen(inventoryContents);

  int current = 0;
  str currentToken = "";
  int iArray = 0;

  for (int i = 0; i < inventoryContentsLength && current < N_INVENTORY_ITEMS; ++i)
  {
    int character = GetChar(inventoryContents, i);
    if (character != '>')
    {
      currentToken = StrParam(s:currentToken, c:character);
    }
    else
    {
      switch (iArray)
      {
      case 0:
        inventoryClasses[current] = currentToken;
        break;
      case 1: inventoryNames[current] = currentToken; ++current; break;
      }

      iArray = (iArray + 1) % 2;
      currentToken = "";
    }
  }

  /*
  for (int j = 0; j < current; ++j)
  {
    Log(s:inventoryClasses[j], s:" : ", s:inventoryNames[j]);
  }
  ///*///

  nInventoryItems = current;
}

function void WM_PrintInventoryMenu(int playerN)
{
  WM_ClearScreen();

  int xStart           = GetUserCVar(playerN, "m8f_wm_InventoryMenuX");
  int backgroundMode   = xStart / 0.5;

  WM_MaybeShowBackground(backgroundMode, playerN);
  WM_SetupFont(playerN);

  int availableColor   = GetUserCVar(playerN, "M8FAvailableWeaponColor");
  int highlightedColor = GetUserCVar(playerN, "M8FHighlightedWeaponColor");
  bool highToLow       = GetUserCVar(playerN, "M8FWeaponMenuHighToLow");

  int yStart           = GetUserCVar(playerN, "m8f_wm_InventoryMenuY");
  int stepMultiplier   = GetUserCVar(playerN, "m8f_wm_StepMultiplier");
  if (stepMultiplier < 0.0) { highToLow = !highToLow; }

  int stepMultiplied = (0.05 * stepMultiplier) >> 16;

  int iBegin;
  int iEnd;
  int iStep;
  if (highToLow) {iBegin = nInventoryItems-1; iEnd = -1;              iStep = -1;}
  else           {iBegin = 0;                 iEnd = nInventoryItems; iStep =  1;}

  str selectedInventoryClass = WM_GetSelectedInventory(playerN);
  int position = 0;
  for (int i = iBegin; i != iEnd; i += iStep)
  {
    int inventoryClass = inventoryClasses[i];
    int amount = CheckInventory(inventoryClass);
    if (amount == 0) { continue; }

    int color;
    if (StrCmp(inventoryClass, selectedInventoryClass) == 0)
    {
      color = highlightedColor;
    }
    else
    {
      color = availableColor;
    }

    WM_PrintInventoryItem(i, position, color, xStart, yStart, stepMultiplied, amount, playerN);
    ++position;
  }

  if (position == 0)
  {
    HudMessage(s:" (Inventory is empty) ";
               msgFlags, msgIdWeapon, availableColor, xStart, yStart, 0);
  }

}

function void WM_PrintInventoryItem( int i
                                   , int position
                                   , int color
                                   , int xStart
                                   , int yStart
                                   , int stepMultiplied
                                   , int amount
                                   , int playerN
                                   )
{
  int id = msgIdWeapon + position;
  int y  = yStart + position * stepMultiplied;
  int x  = xStart;

  str itemString = inventoryNames[i];
  str itemClass  = inventoryClasses[i];

  for (int n = 0; n < N_QUICK_INVENTORY_ITEMS; ++n)
  {
    if (StrCmp(itemClass, WM_GetQuickInventoryItem(n, playerN)) == 0)
    {
      itemString = StrParam(s:itemString, s:" (Q", d:n + 1, s:")");
      break;
    }
  }
  if (amount > 1) { itemString = StrParam(s:itemString, s:" (", d:amount, s:")"); }

  HudMessage(s:" ", s:itemString, s:" "; msgFlags, id, color, x, y, 0);
}

// Zoom Section ////////////////////////////////////////////////////////////////

script "WM_ToggleZoom" (void)
{
  if (IsUninitialized()) { terminate; }

  int playerN = PlayerNumber();

  WM_ToggleZoom(playerN);
}

function bool WM_IsWeaponBeingDeselected(int playerN)
{
  ScriptCall("WMZScriptHelper", "IsWeaponBeingDeselected");
  bool isDeselected = GetUserCVar(playerN, "m8f_wm_ResultInt");
  return isDeselected;
}

function void WM_ToggleZoomWeapon(str weaponClass, int playerN)
{
  if (WM_IsMelee(playerN)) { return; }
  if (WM_IsWeaponBeingDeselected(playerN)) { return; }

  bool isLaserConnected = GetUserCVar(playerN, "m8f_wm_LaserOnZoom");
  bool lowerWeapon      = GetUserCVar(playerN, "m8f_wm_LowerWeaponOnZoom");
  int  zoomedZoomFactor = GetUserCVar(playerN, "m8f_wm_ZoomFactor");

  if (isZoomed)
  {
    zoomFactor = 1.0;
    isZoomed = false;
    SetActorProperty(0, APROP_SPEED, 1.0);
    WM_MaybeToggleSlomoOnZoomOut(playerN);
    WM_MaybeDisableTargetSpy(playerN);
  }
  else
  {
    zoomFactor = zoomedZoomFactor;
    isZoomed = true;
    int zoomSpeedMultiplier = GetUserCvar(playerN, "m8f_wm_ZoomSpeedMultiplier");
    SetActorProperty(0, APROP_SPEED, zoomSpeedMultiplier);
    WM_MaybeToggleSlomoOnZoomIn(playerN);
    WM_MaybeEnableTargetSpy(playerN);
  }

  bool changeZoom = (zoomedZoomFactor != 1.0);
  ScriptCall("WMZScriptHelper", "SetZoomFactor",
             zoomFactor, weaponClass, lowerWeapon, isZoomed, changeZoom);

  if (isLaserConnected)
  {
    SetUserCVar(playerN, "m8f_wm_ShowLaserSight", WM_IsZoomed());
  }
}

function void WM_ToggleZoom(int playerN)
{
  WM_ToggleZoomWeapon(WM_GetWeaponName(selectedWeapon), playerN);
}

function bool WM_IsZoomed(void)
{
  return isZoomed;
}

function void WM_MaybeDisableTargetSpy(int playerN)
{
  if (GetUserCVar(playerN, "m8f_wm_TargetSpyOnZoom"))
  {
    SetUserCVar(playerN, "m8f_ts_enabled", false);
  }
}

function void WM_MaybeEnableTargetSpy(int playerN)
{
  if (GetUserCVar(playerN, "m8f_wm_TargetSpyOnZoom"))
  {
    SetUserCVar(playerN, "m8f_ts_enabled", true);
  }
}

// Fallback Mode Section ///////////////////////////////////////////////////////

function void WM_GetFallbackWeapons(int playerN)
{
  ScriptCall("WMZScriptHelper", "GetWeaponList");

  str weaponData = GetUserCVarString(playerN, "m8f_wm_ResultString");

  int weaponDataLength = StrLen(weaponData);

  int current = 0;
  str currentToken = "";
  int iArray = 0;

  // received data format:
  // Class>Tag>Slot>Class>Tag>Slot ...

  for (int i = 0; i < weaponDataLength && current < MAX_WEAPONS_NUMBER; ++i)
  {
    int character = GetChar(weaponData, i);
    if (character != '>')
    {
      currentToken = StrParam(s:currentToken, c:character);
    }
    else
    {
      switch (iArray)
      {
      case 0: names[SET_FALLBACK][current] = currentToken; break;
      case 1: tags [SET_FALLBACK][current] = currentToken; break;
      case 2:
        slots[SET_FALLBACK][current] = WM_StrToInt(currentToken);
        break;
      case 3:
        priority[current] = WM_StrToInt(currentToken);
        ++current;
        break;
      }

      iArray = (iArray + 1) % 4;
      currentToken = "";
    }
  }

  weaponCounts[SET_FALLBACK] = current;
  weaponCount = current;

  WM_SortFallbackByPriority(playerN);
  WM_SortFallbackBySlot(playerN);

  /*
  for (int j = 0; j < current; ++j)
  {
    Log(s:names[SET_FALLBACK][j],
        s:" : ", s:tags [SET_FALLBACK][j],
        s:" : ", d:slots[SET_FALLBACK][j],
        s:" : ", d:priority[j]
        );
  }
  Log(i:weaponCounts[SET_FALLBACK]);
  ///*///
}

// works only for positive numbers
function int WM_StrToInt(str stringNumber)
{
  int result = 0;
  int length = StrLen(stringNumber);

  for (int i = 0; i < length; ++i)
  {
    result *= 10;
    result += GetChar(stringNumber, i) - '0';
  }

  return result;
}

function void WM_SortFallbackByPriority(int playerN)
{
  // Quicksort, because it's simple and faster than insertion sort.
  WM_QuicksortByPriority(0, weaponCount - 1, playerN);
}

function void WM_QuicksortByPriority(int lo, int hi, int playerN)
{
  if (lo < hi)
  {
    int p = WM_QuicksortByPriorityPartition(lo, hi, playerN);
    WM_QuicksortByPriority(lo,    p - 1, playerN);
    WM_QuicksortByPriority(p + 1, hi,    playerN);
  }
}

function int WM_QuicksortByPriorityPartition(int lo, int hi, int playerN)
{
  int pivot   = priority[hi];
  int i       = lo - 1;

  for (int j = lo; j <= hi - 1; ++j)
  {
    if (priority[j] > pivot)
    {
      ++i;
      WM_SwapWeapons(i, j, false, playerN);
    }
  }
  WM_SwapWeapons(i + 1, hi, false, playerN);

  return i + 1;
}

function void WM_SortFallbackBySlot(int playerN)
{
  // Insertion sort, because it's stable and simple.
  WM_InsertionSortBySlot(playerN);
}

function void WM_InsertionSortBySlot(int playerN)
{
  for (int i = 1; i < weaponCount; ++i)
  {
    for (int j = i;
         j > 0 && WM_SlotIsHigher(WM_GetWeaponSlot(j - 1), WM_GetWeaponSlot(j));
         --j)
    {
      WM_SwapWeapons(j, j - 1, false, playerN);
    }
  }
}

// The main purpose of this function is that slot 0 is considered higher than
// other slots
function bool WM_SlotIsHigher(int slot1, int slot2)
{
  if (slot1 == 0) { slot1 = 99; }
  if (slot2 == 0) { slot2 = 99; }
  return slot1 > slot2;
}

// Inventory Controls Section //////////////////////////////////////////////////

function str WM_GetSelectedInventory(int playerN)
{
  ScriptCall("WMZscriptHelper", "GetSelectedInventory");
  return GetUserCVarString(playerN, "m8f_wm_ResultString");
}

function str WM_GetInventoryTag(str itemClass, int playerN)
{
  ScriptCall("WMZscriptHelper", "GetInventoryTag", itemClass);
  return GetUserCVarString(playerN, "m8f_wm_ResultString");
}

function str WM_GetQuickInventoryCVarName(int n)
{
  str cvarName = StrParam(s:"m8f_wm_QuickInventoryItem", d:n);
  return cvarName;
}

function str WM_GetQuickInventoryItem(int n, int playerN)
{
  if (n >= N_QUICK_INVENTORY_ITEMS) { return "none"; }
  str cvarName = WM_GetQuickInventoryCVarName(n);
  str quickInventory = GetUserCVarString(playerN, cvarName);
  return quickInventory;
}

function void WM_SetQuickInventoryItem(int n, str quickInventory, int playerN)
{
  if (n >= N_QUICK_INVENTORY_ITEMS) { return; }
  str cvarName = WM_GetQuickInventoryCVarName(n);
  SetUserCVarString(playerN, cvarName, quickInventory);
}

script "WM_ToggleQuickInventoryItem" (void)
{
  if (IsUninitialized()) { terminate; }

  int playerN           = PlayerNumber();
  str selectedInventory = WM_GetSelectedInventory(playerN);
  if (StrCmp(selectedInventory, "wm_none") == 0) { terminate; }

  str tag = WM_GetInventoryTag(selectedInventory, playerN);

  int i;

  // if found in quick access, remove it and quit
  for (i = 0; i < N_QUICK_INVENTORY_ITEMS; ++i)
  {
    if (StrCmp(WM_GetQuickInventoryItem(i, playerN), selectedInventory) == 0)
    {
      WM_SetQuickInventoryItem(i, "", playerN);
      Log(s:tag, s:": no longer in quick access.");
      terminate;
    }
  }

  // put in first empty quick access slot
  for (i = 0; i < N_QUICK_INVENTORY_ITEMS; ++i)
  {
    if (StrLen(WM_GetQuickInventoryItem(i, playerN)) == 0)
    {
      WM_SetQuickInventoryItem(i, selectedInventory, playerN);
      Log(s:tag, s:": marked as quick access #", i:i + 1);
      break;
    }
  }
}

script "WM_ClearQuickInventoryItems" (void)
{
  int playerN = PlayerNumber();

  for (int i = 0; i < N_QUICK_INVENTORY_ITEMS; ++i)
  {
    WM_SetQuickInventoryItem(i, "", playerN);
  }
  Log(s:"Quick Inventory Item List is cleared.");
}

script "WM_UseQuickInventoryItem" (int n)
{
  if (n >= N_QUICK_INVENTORY_ITEMS) { terminate; }

  int playerN = PlayerNumber();

  str item = WM_GetQuickInventoryItem(n, playerN);
  str tag  = WM_GetInventoryTag(item, playerN);

  int count = CheckInventory(item);
  if (count == 0)
  {
    Log(s:tag, s:": not in inventory.");
    terminate;
  }

  bool success = UseInventory(item);
  if (!success)
  {
    Log(s:"Could not use ", s:tag);
  }
}

// Game Detection Section //////////////////////////////////////////////////////

function bool WM_IsDoom1(void)
{
  str  filtered = StrParam(l:"WM_GAME");
  bool doom1    = (StrCmp(filtered, "1") == 0);
  return doom1;
}

function bool WM_IsDoom2(void)
{
  str  filtered = StrParam(l:"WM_GAME");
  bool doom2    = (StrCmp(filtered, "2") == 0);
  return doom2;
}

function bool WM_IsFreedoom1(void)
{
  str  filtered  = StrParam(l:"WM_GAME");
  bool freedoom1 = (StrCmp(filtered, "4") == 0);
  return freedoom1;
}

function bool WM_IsFreedoom2(void)
{
  str  filtered  = StrParam(l:"WM_GAME");
  bool freedoom2 = (StrCmp(filtered, "3") == 0);
  return freedoom2;
}

function bool WM_IsRekkr(void)
{
  str  checkString = StrParam(l:"E1TEXT");
  str  rekkrString = "You've been through war.";
  int  rekkrLength = StrLen(rekkrString);
  bool isRekkr     = StrICmp(rekkrString, StrLeft(checkString, rekkrLength)) == 0;
  return isRekkr;
}

function bool WM_IsHarmony(void)
{
  str checkString = StrParam(l:"C1TEXT");
  str harmString = "HEADING DOWN YOU FINALLY HAVE";
  int harmLength = StrLen(harmString);
  bool isHarmony = StrICmp(harmString, StrLeft(checkString, harmLength)) == 0;
  return isHarmony;
}

function bool WM_IsEVP(void)
{
  bool isEVP = CheckClass("EVPBFGBall");
  return isEVP;
}

function bool WM_IsVSmooth(void)
{
  bool hasSmoothChainsaw = CheckClass("SmoothChainsaw");
  bool hasSmoothFist     = CheckClass("PerkFist");

  return hasSmoothChainsaw && !hasSmoothFist;
}

function bool WM_IsFlakesDoom(void)
{
  bool isFlakesDoom = CheckClass("FKHAR");
  return isFlakesDoom;
}

function bool WM_IsAbortM(void)
{
  bool isAbortM = CheckClass("AbortButton");
  return isAbortM;
}

function bool WM_IsCyanDoom(void)
{
  bool isCyanDoom = CheckClass("STMinigun")
    && CheckClass("Daedabus")
    && CheckClass("VitalitySerum");
  return isCyanDoom;
}

// Infinite Slot 1 Ammo Section ////////////////////////////////////////////////

script "WM_GiveMinSlot2Ammo" (void)
{
  if (IsUninitialized()) { terminate; }

  if (selectedWeapon == WEAPON_HOLSTERED) { terminate; }
  int slot = WM_GetWeaponSlot(selectedWeapon);
  if (slot != 2) { terminate; }

  str weaponClass = WM_GetWeaponName(selectedWeapon);
  ScriptCall("WMZscriptHelper", "GiveMinAmmo", weaponClass);
}

// Slomo Bullettime Section ////////////////////////////////////////////////////

function void WM_MaybeToggleSlomoOnOpen(int playerN)
{
  bool slomoOnMenuOpen = GetUserCVar(playerN, "m8f_wm_SlomoOnMenuOpen");
  if (slomoOnMenuOpen)
  {
    SetCVar("m8f_sm_externaltoggle", 1);
  }
}

function void WM_MaybeToggleSlomoOnClose(int playerN)
{
  bool slomoOnMenuOpen = GetUserCVar(playerN, "m8f_wm_SlomoOnMenuClose");
  if (slomoOnMenuOpen)
  {
    SetCVar("m8f_sm_externaltoggle", 1);
  }
}

function void WM_MaybeToggleSlomoOnZoomIn(int playerN)
{
  bool slomoOnMenuOpen = GetUserCVar(playerN, "m8f_wm_SlomoOnZoomIn");
  if (slomoOnMenuOpen)
  {
    SetCVar("m8f_sm_externaltoggle", 1);
  }
}

function void WM_MaybeToggleSlomoOnZoomOut(int playerN)
{
  bool slomoOnMenuOpen = GetUserCVar(playerN, "m8f_wm_SlomoOnZoomOut");
  if (slomoOnMenuOpen)
  {
    SetCVar("m8f_sm_externaltoggle", 1);
  }
}

function void WM_MaybeToggleSlomoOnQuick(int playerN)
{
  bool slomoOnMenuOpen = GetUserCVar(playerN, "m8f_wm_SlomoOnQuickAccess");
  if (slomoOnMenuOpen)
  {
    SetCVar("m8f_sm_externaltoggle", 1);
  }
}

function void WM_MaybeToggleSlomoOnInvOpen(int playerN)
{
  bool slomoOnMenuOpen = GetUserCVar(playerN, "m8f_wm_SlomoOnInventoryOpen");
  if (slomoOnMenuOpen)
  {
    SetCVar("m8f_sm_externaltoggle", 1);
  }
}

function void WM_MaybeToggleSlomoOnInvClose(int playerN)
{
  bool slomoOnMenuOpen = GetUserCVar(playerN, "m8f_wm_SlomoOnInventoryClose");
  if (slomoOnMenuOpen)
  {
    SetCVar("m8f_sm_externaltoggle", 1);
  }
}

// Switch to most powerful weapon section //////////////////////////////////////

script "WM_SwitchToPowerful" (void)
{
  if (IsUninitialized()) { terminate; }

  for (int i = weaponCount - 1; i >= 0; --i)
  {
    str weaponClass = WM_GetWeaponName(i);
    if (!CheckInventory(weaponClass)) { continue; }

    int slot = WM_GetWeaponSlot(i);
    if (slot == 0) { continue; }
    if (i != 0)
      if (CheckInventory(WM_GetWeaponName(i - 1)) &&
          WM_GetWeaponSlot(i - 1) == slot) { continue; }

    if (SetWeapon(weaponClass)) { break; }
  }
}
